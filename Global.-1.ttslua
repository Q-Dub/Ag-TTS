function onload(saveState)
	math.randomseed( os.time() ) -- ensure some good chaos

	Game = getObjectFromGUID('40398f') -- general helper object for common tasks

	Ag = {
		testMode = false,
		gameStarted = false,

		Bags = {
			Decks = {
				E = { 'a9001e', '4d756f', 'e89fab', minors = '9eb064' },
				I = { '261a94', 'cf7151', 'a234ca', minors = '47d57c' },
				K = { 'c48309', 'c8684f', '484524', minors = '9e3d4c' },
			 WM = { '4946bc', 'd38fd4', minors = '28b771' },
			 FR = { '8f577a', '9c5589', '41a73a', minors = '8afe39' },
			  G = { '43f2ae', '5a3815', '0a6682', minors = 'fb6a79' },
			  C = { 'cecf3c', '298ee2', '8888f9', minors = 'a4d426' },
			 FL = { '5218e8', '822734', 'a74514', minors = 'c54cb9' },
			 WA = { 'a5d80c', 'cb2bae', 'b8e204', minors = '0b6410' },
		 	},
			decks = { E = '9eb064', I = '47d57c', K = '9e3d4c', WM = '28b771', FR = '8afe39',
								G = 'fb6a79', C = 'a4d426', FL = 'c54cb9', WA = '0b6410'},
			draftRejects = 'ad63e8', -- bag to discard undrafted cards if > 7 dealt
			playerCards = {},
			stages = { '452df5', '56715e', '71ca23', 'e0030c', '6469a3', 'cdf47c' }
		},
		Boards = {
			Players = { Red = '7c4084', Purple = 'd349b2', Green = '454b89', Blue = '858dea', White = '179cb5' },

			--TODO implement accounting for board resize when calculating seed positions
			Main = {
				DayLab = {
					cardPositions = {},
					guid = '78928b',
					-- -1, 5.2, 2.92
					positionOffsets = { {3.202, 0, -4.35}, {0.282, 0, -4.35}, {3.202, 0, 0},
															{0.282, 0, 0}, {3.202, 0, 4.531}, {0.282, 0, 4.531} },
					rotation = {},
					scale = {6.92, 1.00, 6.92},
					scaleMultiplier = {}
				},

				Fishing = {
					cardPositions = {},
					guid = 'e7d3f6',
					positionOffsets = {
						{-3.33, 0, -7.72}, {-0.17, 0,5.83}, {-0.17, 0,0.05},
						{-0.17,0,-4.54}, {3.06,0,4.24}, {3.06,0,-0.04}, {3.06, 0, -4.54}
					},
					rotation = {},
					scale = {6.92, 1.00, 6.92},
					scaleMultiplier = {}
				},

				EndGame = {
					cardPositions = {},
					guid = '375a44',
					positionOffsets = {
						{4.97,0,2.3}, {-4.32,0,-1.95}, {-1.75,0,2.26},
						{-1.75,0,-2.07}, {1.55,0,2.3}, {1.55,0,-2.21}, {4.48,0,2.3}
					},
					rotation = {},
					scale = {4.91, 1, 4.91},
					scaleMultiplier = {}
				},
			},
		},
		Buttons = {
			dealCards ='809d48',
			nextRound = '5c35ac',
			passCW = 'a76aa9',
			passCCW = '604b8e'
		},
		Cards = {
			beggars 		= 'f28a11',
			draftActionQueue = {},
			InPlay = {
				numPlayerActions = {},
				roundCards = {}
			},
			loadedOccs = 0,
			loadedMinors = {},
			occsDealt = false,
			--banned = { "bb70d6", "75d63d", "d6664f", "2815da", "435636" },
			PlayerCards = {},
			RoundCards 	= {
				{ name = 'sheep', guid = '85b867', stage = 1 }, { name = 'majorMinor', guid = 'cda9b3', stage = 1 },
				{ name = 'fences', guid = 'e5f7cd', stage = 1 }, { name = 'sowBake', guid = '8eeb11', stage = 1 },
				{ name = 'familyGrowth', guid = 'bded46', stage = 2 }, { name = 'stone', guid = '0d7a31', stage = 2 },
				{ name = 'renoMajor', guid = 'c8762e', stage = 2 }, { name = 'boar', guid = '6c1287', stage = 3 },
				{ name = 'veg', guid = '202efb', stage = 3 }, { name = 'cow', guid = '1e18f2', stage = 4 },
				{ name = 'stone', guid = 'd37bf8', stage = 4 }, { name = 'plowSow', guid = '1a8ef8', stage = 5 },
				{ name = 'fgSansSpace', guid = '618af7', stage = 5 }, { name = 'renoFence', guid = 'a1e455', stage = 6}
			},
			stages = { 'e76b68', 'bd32c0', '25abf3', '128b47', '1e0879', 'a1e455' } -- 1-6, respectively
		},
		HeightOffsets = {
			table = 1, tile = 0.15
		},
		Players = {
			draftIndicators = { Purple = 'b57b80', Green = '80bcd4', Blue = '1c4ce5', White = '76cb43', Red = 'abf3a9' },
			homePositions = {},
			homeRotations = {},
			startFood = { Purple = 'bdb99f', Green = 'd8104a', Blue = '92513f', White = '6a3791', Red = '4dd18c' },
			startPlayerMarker = '7ea756'
		},
		SaveData = {
			Cards = {
				Draft = { pickNumber = 1 },
				initialHandSize = 7,
				InPlay = {
					RoundCardData = {},
					decks = {},
					minorDecksInZone = 0,
					numMinorStacks = 0,
					numOccStacks = 0,
					occDecksInZone = 0,
				},
				numPlayerActionsSpawned = false,
				ProxyMinorBag = {}, -- virtual bag to prevent having to load every card
				ProxyOccBag = {}, -- virtual bag to prevent having to load every card
				roundCardsSpawned = false,
				seedScriptsAttached = false,
			},
			phase = '',
			Players = {
				DraftPicks = {},
				inGame = {},
				peeps = {
					Purple = { '3e264f', '02e0cb' },
					Red = { 'e66902', '93283f' },
					White = { '5b51c1', '513e3a' },
					Green = { 'c605ed', 'a20582' },
					Blue = { '236b56', 'e79989' }
				},
				startPlayer = '',
			},
			roundNumber = 0,
	 	},
		ScriptingZones = {
			actionSpaces = {}, -- populates dynamically after cards are seeded
			deckSelectButtons = '8b293c',
			minors = '392c2f',
			occs = '346893',
			Players = {
				Draft = { Purple = '30e021', Green = '6d2710', Blue = 'fb4fd8', White = 'db122a', Red = 'e98fe7' },
				Hands = { Purple = '77f215', Green = 'aecae1', Blue = 'f273b8', White = '338995', Red = '700997' },
				HandObjects = {} -- getObjectFromGUID of Hands of players actually in game
			}
		},
		SelectedDecks = {},
		SpawnBoards = {
			Master = {
				food = 'b9754f', grain = '2459f4', veg = '391c13',
				wood = 'c4d916', clay = '4e06e8',  stone = 'fe3238',
				reed = '9c217a', sheep = 'ca7c6c', boar = 'd02a32',
				cow = 'ee948a', food_5 = '68d5e2'
			},
			Players = {
				Purple = { peepBag = '997519'},
				Green = { peepBag = '320883'},
				Blue = { peepBag = '6f3666'},
				White = { peepBag = 'ecd257'},
				Red = { peepBag = '578d4a'}
			}
		},
		Style = { broadcastTint = {200/255,1,200/255} },
		Table = '0b2ed0',
		Temp = {},
		Tiles = { occ = '756dc7',
							minor = '2812f4' }
	}

	Ag.Bags.playerCards[3] = 'b4aad8'
	Ag.Bags.playerCards[4] = 'eb2550'
	Ag.Bags.playerCards[5] = '6fd961'

	Ag.Cards.PlayerCards[3] = {
		{ guid = 'c2aaf9', name = 'clay', qty = 1}, { guid = '11e22f', name = 'wood', qty = 2 },
		{ guid = 'bc4db6', name = 'occ'}, { guid = '706011', name = 'wild' }
	}

	Ag.Cards.PlayerCards[4]	= {
		{ guid = '05b151', name = 'wood', qty = 1 }, { guid = '3cb828', name = 'wood', qty = 2 },
		{ guid = '12a697', name = 'clay', qty = 2 }, { guid = 'bc3466', name = 'occ' },
		{ guid = '10953e', name = 'gSpot' }, { guid = 'c418a2', name = 'food', qty = 1 } -- food is really T.P.
	}

	-- the 'reed' is really gSpot, and 'food' is really T.P.
	Ag.Cards.PlayerCards[5]	= {
		{ guid = '470341', name = 'wood', qty = 4 }, { guid = '1316e0', name = 'clay', qty = 3},
		{ guid = '37a094', name = 'zoo' }, { guid = 'd4d96d', name = 'occ'},
		{ guid = 'dc9600', name = 'reed', qty = 1 }, { guid = 'c9a1e2', name = 'food', qty = 1}
	}

	if(Ag.testMode == true) then
		Ag.SaveData.Cards.initialHandSize = 1
	end

	if( saveState ~= '') then
    --Ag.SaveData = JSON.decode(saveState)
		--createObjectsFromSaveState(Ag.SaveData)
	end

	if(Ag.SaveData.phase == '') then
		--disableDraftIndicators()
		createButtons()
	else
		--spawnScriptingZones()
		--createNextRoundButton()
		--attachSeedScripts()
	end
	--UI.setAttribute('dealButtons', 'active', false)
  --UI.setAttribute('dealLayout', 'height', 40)
  --minors_button = minors_setup()
  --occs_button = occs_setup()
end

function createObjectsFromSaveState(saveData)
	if( saveData.Cards.InPlay.RoundCardData ~= nil ) then
		roundCardsToObjects()
	end
end

function createObjectsFromGUIDs()
	local params = {
		isIndexed = false,
		table = Ag.SpawnBoards.Master
	}
	Ag.SpawnBoards.Master = guidsToObjects(params)

	local params = {
		isIndexed = false,
		table = Ag.Players.draftIndicators
	}
	Ag.Players.draftIndicators = guidsToObjects(params)

	params = {
		isIndexed = true,
		table = Ag.Bags.stages
	}
	Ag.Bags.stages = guidsToObjects(params)

	-- hand zone instances for players in the game
	local color
	for _, color in ipairs(Ag.SaveData.Players.inGame) do
		Ag.ScriptingZones.Players.HandObjects[color] = getObjectFromGUID( Ag.ScriptingZones.Players.Hands[color] )
	end

	Ag.Tiles.occ = getObjectFromGUID(Ag.Tiles.occ)
	Ag.Tiles.minor = getObjectFromGUID(Ag.Tiles.minor)
end

function disableDraftIndicators()
	local params = {
		table = Ag.Players.draftIndicators,
		props = {
			interactable = false
		}
	}
	setTableProps(params)
end

function createButtons()
	createDealButton()
	createPassCCWButton()
	createPassCWButton()
	createNextRoundButton()

	if(Ag.testMode) then
		createTestButton()
		createTestButtonTwo()
	end
end

function createDealButton()
	local dealButton = getObjectFromGUID(Ag.Buttons.dealCards)
	local params = {
		click_function = 'onClickDealCards',
	  position = {0, 0, 0},
	  width = 900,
	  height = 900,
		tooltip = "Deal Cards\n\nPress '1' or '2' over the deck buttons to toggle."
	}
  dealButton.createButton(params)
end

function createPassCCWButton()
	local dealButton = getObjectFromGUID(Ag.Buttons.passCCW)
	local params = {
		click_function = 'onClickPassCCW',
	  position = {0, 0, 0},
	  width = 900,
	  height = 900,
		tooltip = "Pass OCCS"
	}
  dealButton.createButton(params)
end

function createPassCWButton()
	local dealButton = getObjectFromGUID(Ag.Buttons.passCW)
	local params = {
		click_function = 'onClickPassCW',
	  position = {0, 0, 0},
	  width = 900,
	  height = 900,
		tooltip = "Pass MINORS"
	}
  dealButton.createButton(params)
end

function onClickPassCW(obj)
	passHands(true)
end

function onClickPassCCW(obj)
	passHands(false)
end

function createDealSingleOccButton()
	--local dealButton = getObjectFromGUID(Ag.Tiles.occ)
  local params = {
		label = 'Draw an\nOcc',
		click_function = 'onClickDealSingleOcc',
	  position = {0, 0, 0},
	  width = 900,
	  height = 900
	}
  --dealButton.createButton(params)
	--local tile = Ag.Tiles.occ
	local tile = getObjectFromGUID('756dc7')
	tile.createButton(params)
end

function createDealSingleMinorButton()
	--local dealButton = getObjectFromGUID(Ag.Tiles.minor)
  local params = {
		label = 'Draw a\nMinor',
		click_function = 'onClickDealSingleMinor',
	  position = {0, 0, 0},
	  width = 900,
	  height = 900
	}
  --dealButton.createButton(params)
	local tile = getObjectFromGUID('2812f4')
	tile.createButton(params)
	--Ag.Tiles.minor.createButton(params)
end

function createNextRoundButton()
	local testButton = getObjectFromGUID(Ag.Buttons.nextRound)
  local params = {
		click_function = 'onClickNextRoundButton',
	  position = {0, 0, 0},
	  width = 900,
	  height = 900
	}
  testButton.createButton(params)
end

function onClickDealCards(obj)
	getPlayers()
	assignStartPlayer()
	local numPlayers = #Ag.SaveData.Players.inGame

	if(numPlayers == 0) then
		broadcastToAll('Agricola plays 1-5 players!\n Click your name in the top right and select \'Change Color\'.', Ag.Style.broadcastTint)
	elseif( (numPlayers > 0) and (numPlayers < 6) ) then
		if(Ag.Cards.occsDealt == false) then
			Ag.Cards.occsDealt = true
			createObjectsFromGUIDs() -- some objects depend on knowing which players are in the game
			setupCards()
			spawnScriptingZones()
			assembleProxyBags()
			dealCards('occs')
			if(numPlayers > 1) then
				--startLuaCoroutine(self, 'startDraft')
				broadcastToAll('Starting game with ' .. numPlayers .. ' players', Ag.Style.broadcastTint)
			else
				broadcastToAll('Starting solo game', Ag.Style.broadcastTint)
				startLuaCoroutine(self, 'startGame')
				Ag.gameStarted = true
				dealCards('minors') --TODO deal minors to minor draft hand
			end
		else
			dealCards('minors')
			createDealSingleOccButton()
			createDealSingleMinorButton()
			obj.destruct()
		end
	else
		broadcastToAll('Wow, ' .. numPlayers .. ' players want to play, but max 5 players!', Ag.Style.broadcastTint)
	end
end

function assignStartPlayer()
		local numPlayers = #Ag.SaveData.Players.inGame
		local startPlayer =	math.random(1, numPlayers)
		--log(Ag.SaveData.Players.inGame[startPlayer] .. ' is the start playe
		refreshPlayerBoardPositions()
		movePylon(startPlayer)
		deleteFood(startPlayer, 1)
end

function movePylon(playerPosition)
	local playerColor = Ag.SaveData.Players.inGame[playerPosition]
 	local boardPosition = Ag.Players.homePositions[playerColor]
	boardPosition.y = boardPosition.y + 2
	local pylon = getObjectFromGUID(Ag.Players.startPlayerMarker)
	pylon.setPositionSmooth(boardPosition, false, false)
end

function deleteFood(player, qty)
	-- for now this just can delete one of the initial food
	local playerColor = Ag.SaveData.Players.inGame[player]
	local food = getObjectFromGUID(Ag.Players.startFood[playerColor])
	food.destruct()
end

function dealCards(cardType)
	local color
	local rotation = { 0, 0, 0 }
	Ag.SaveData.phase = 'dealing'

	for _, color in ipairs(Ag.SaveData.Players.inGame) do
		if(color == 'Purple' or color == 'Red') then rotation = { 0, 180, 0 } end
		if(color == 'White') then rotation = { 0, 90, 0 } end
		local handPosition = getPlayerHandPosition(color)
		handPosition.y = handPosition.y + 1
		local proxyBag
		if(cardType == 'occs') then
			proxyBag = Ag.SaveData.Cards.ProxyOccBag
		else
			proxyBag = Ag.SaveData.Cards.ProxyMinorBag
		end

		log('handSize:')
		log(Ag.SaveData.Cards.initialHandSize)
		dealFromProxyBag( proxyBag, Ag.SaveData.Cards.initialHandSize, handPosition, rotation, color )
	end
end

function onClickDealSingleOcc()
	local faceDown = true
	local target = getObjectFromGUID(Ag.ScriptingZones.occs)
	local position = target.getPosition()
	local rotation = target.getRotation()
	rotation.z = 180
	dealFromProxyBag(Ag.SaveData.Cards.ProxyOccBag, 1, position, rotation, '', faceDown)
end

function onClickDealSingleMinor()
	local faceDown = true
	local target = getObjectFromGUID(Ag.ScriptingZones.minors)
	local position = target.getPosition()
	local rotation = target.getRotation()
	rotation.z = 180
	dealFromProxyBag(Ag.SaveData.Cards.ProxyMinorBag, 1, position, rotation, '', faceDown)
end

function onClickNextRoundButton(obj, player_clicker_color)
	if(Ag.gameStarted == false) then
		Ag.gameStarted = true
		startLuaCoroutine(self, 'startGame')
	else
  	startLuaCoroutine(self, 'startNextRound')
	end
end

function onClickDealOption()
  printToAll('Deal Options Changed!')
end

function createTestButton()
	--log('entered createTestButton')
	local testButton = getObjectFromGUID('5a218f')
  local params = {
		click_function = 'onClickTestButton',
	  position = {0, 0, 0},
	  width = 900,
	  height = 900
	}
  testButton.createButton(params)
end

function createTestButtonTwo()
	local testButton = getObjectFromGUID('198515')
  local params = {
		click_function = 'onClickTestButtonTwo',
	  position = {0, 0, 0},
	  width = 900,
	  height = 900
	}
  testButton.createButton(params)
end

function assembleProxyBags()
	-- form virtual bags so we can pull (and therefore load) the minimum number of cards required
	-- TODO account for broom, governor, etc.

	local numPlayers = #Ag.SaveData.Players.inGame
	local buttonZone = getObjectFromGUID(Ag.ScriptingZones.deckSelectButtons)
	local deckButtons = buttonZone.getObjects()
	local selectedDecks, sortedDecks, chosenDecks = {}, {}, {}
	local deckButton

	-- get data for which decks are selected
	for _, deckButton in ipairs(deckButtons) do
		if( deckButton.getStateId() == 1) then
			chosenDecks[#chosenDecks + 1] =  deckButton.getName()
		end
	end

	-- check at least one deck has been selected
	Ag.selectedDecks = chosenDecks
	if( Ag.selectedDecks == nil) then
		broadcastToAll('Please select at least one deck.\nHover over the deck buttons and press \'1\' to add, or \'2\' to remove.', Ag.Style.broadcastTint)
		return false
	end

	local params = { unorderedTable = chosenDecks, orderedTable = Ag.Bags.decks }
	sortedDecks = Game.call('matchTableKeyOrder', params)
	Ag.SaveData.Cards.InPlay.decks = sortedDecks

	local deckName, currentBag, deckNumber, stacksNeeded
	local proxyOccBag, proxyMinorBag = {}, {}

	for _, deckName in ipairs(sortedDecks) do
		-- * * * add the minors to the proxy bag * * *
		currentBag = getObjectFromGUID(Ag.Bags.Decks[deckName].minors)
		local minor
		local numMinors = currentBag.getQuantity()
		for minor = 1, numMinors do
			-- create a table of GUIDs, from which we will randomize the hands
			table.insert( proxyMinorBag, Ag.Bags.Decks[deckName].minors )
			--proxyMinorBag[#proxyMinorBag + 1] = Ag.Bags.Decks[deckName].minors
		end

		-- * * * add occupations in the bag, but check for numPlayers * * *
		local i
		for i = 1, #Ag.Bags.Decks[deckName] do
			if( (i == 2) and (numPlayers < 3) ) then break end
			if( (i == 3) and (numPlayers < 4) ) then break end

			currentBag = getObjectFromGUID( Ag.Bags.Decks[deckName][i] )
			local occ
			local numOccs = currentBag.getQuantity()
			for occ = 1, numOccs do
					-- create a table of GUIDs, from which we will randomize the hands
				table.insert( proxyOccBag, Ag.Bags.Decks[deckName][i] )
				--proxyOccBag[#proxyOccBag + 1] = Ag.Bags.Decks[deckName][i]
			end
		end
	end

	Ag.SaveData.Cards.ProxyOccBag = proxyOccBag
	Ag.SaveData.Cards.ProxyMinorBag = proxyMinorBag
end

function dealFromProxyBag(proxyBag, numCards, position, rotation, color, reverse)
	reverse = reverse or false
	local obj, i, currentBag, key

	cardGUIDs = takeFromProxyBag(proxyBag, numCards)
	local guid
	for _, guid in ipairs(cardGUIDs) do
		currentBag = getObjectFromGUID(guid)
		currentBag.shuffle()

		if(faceDown) then rotation.z = 180 end

		if( color ~= '' ) then
			currentBag.deal(1, color, 1)
		else
			local params = {
				index = 1,
				position = position,
				rotation = rotation
			}
			currentBag.takeObject(params)
		end
	end
end

function takeFromProxyBag(proxyBag, numCards)
	local numItems = #proxyBag
	local card, bagGUID, i
	local cardGUIDs = {}

	for i = 1, numCards do
		card = math.random(1, numItems)
		bagGUID = proxyBag[card]
		table.insert( cardGUIDs, bagGUID)
		table.remove(proxyBag, card)
		numItems = numItems - 1
	end

	return cardGUIDs
end

function onOccsLoaded(obj, deckName, occType, stacksNeeded)
	local numPlayers = #Ag.SaveData.Players.inGame

	--print(occType .. '+ occs loaded for ' .. deckName .. ' deck')
	Ag.Cards.loadedOccs =  Ag.Cards.loadedOccs + 1
	if(Ag.Cards.loadedOccs == stacksNeeded) then
		--startLuaCoroutine(self, 'startDraft')
	end
	--print('loaded: ' .. Ag.Cards.loadedOccs .. ' | needed: ' .. stacksNeeded)
	--print('===========')
end

function startDraft()
	-- wait a few moments, so that cards entering hand zones don't trigger functions
	while(cardsDealt() == false) do
		coroutine.yield(0)
	end

	Ag.SaveData.phase = 'draft'
	removeUnusedSeats()

	return 1
end

function cardsDealt()
	-- check for seeing if all cards have arrived in players hands
	local color
	for _, color in ipairs(Ag.SaveData.Players.inGame) do
		local handGUID = Ag.ScriptingZones.Players.Hands[color]
		local hand = getObjectFromGUID(handGUID)
		if(#hand.getObjects() ~= Ag.SaveData.Cards.initialHandSize) then
			return false
		end
	end
	return true
end

function removeUnusedSeats()
	-- TODO remove all pieces as well (low priority, as all can be manually deleted,
	-- and additional pain if drafting has started, and someone wants to jump in without reseting draft)
	local colorInGame = false

	for color, indicator in pairs(Ag.Players.draftIndicators) do
		colorInGame = Game.call('inTable', { table = Ag.SaveData.Players.inGame, searchValue = color } )
		if(colorInGame == false) then
			Ag.Players.draftIndicators[color] = nil
			indicator.destruct()
			--local board = getObjectFromGUID(Ag.Boards.Players[color])
			--board.destruct()
		end
	end
end

function setupCards()
	startLuaCoroutine(self, 'placeNumPlayerActions')
	startLuaCoroutine(self, 'placeRoundCards')
end

function nextDraftStep()
	-- put a dealy, so that draft indicators are accurate
	flipDraftIndicators('x')
	--waitFrames(3)

	local picksMade = Ag.SaveData.Cards.Draft.pickNumber
	Ag.SaveData.Cards.Draft.pickNumber = Ag.SaveData.Cards.Draft.pickNumber + 1
	local maxPicks = math.min(Ag.SaveData.Cards.initialHandSize, 7)

	if(picksMade < maxPicks) then
		passHands(false) -- pass Occs CCW
	elseif(picksMade == maxPicks) then
		cleanupHands()
		dealCards('minors')
	elseif(picksMade < (maxPicks * 2)) then
		passHands(true) -- pass minors CW
	else
		startLuaCoroutine(self, 'startGame')
	end

	return 1
end

function passHands(clockwise)
	local players = Ag.SaveData.Players.inGame
	local i
	for i, playerColor in ipairs(players) do
		local passToColor

		if(clockwise) then
			if(i == #players) then passToColor = players[1]
			else passToColor = players[i + 1] end
		else
			if(i == 1) then passToColor = players[#players]
			else passToColor = players[i - 1] end
		end

		local j, card
		for j, card in ipairs(Player[playerColor].getHandObjects() ) do
			local destVector = getPlayerHandPosition(passToColor)
			destVector.y = destVector.y + 1
			card.setPosition(destVector, false, false)
			card.setRotation({0, Player[passToColor].getHandTransform(1).rotation[2]+180, 0})
		end
	end
end

function getPlayerHandPosition(color)
	local handData = Player[color].getPlayerHand()
	return { handData.pos_x, handData.pos_y, handData.pos_z,
					 x = handData.pos_x, y = handData.pos_y, z = handData.pos_z }
end

function cleanupHands()
	--TODO
	-- remove extra cards post-draft or between occs and minors
	local bag = getObjectFromGUID(Ag.Bags.draftRejects)
end

function deleteDraftIndicators()
	for _, indicator in pairs(Ag.Players.draftIndicators) do
		if(indicator ~= nil) then indicator.destruct() end
	end
end

function dealMinors()
	local minorZone = getObjectFromGUID(Ag.ScriptingZones.minors)
	local zoneObjects = minorZone.getObjects()
	local minorStack = zoneObjects[1]
	local targetZones = {}

	for _, color in pairs(Ag.SaveData.Players.inGame) do
		table.insert(targetZones,  Ag.ScriptingZones.Players.Hands[color])
	end

	Game.call('deal', { stack = minorStack, numCards = Ag.SaveData.Cards.initialHandSize, targetGUIDs = targetZones})
end

function getPlayers()
	local inGame = {}
	inGame = Game.call('playerSnapshot')

	-- put the list in clockwise order
	inGameCW = Game.call('getColorOrderCW', inGame)

	-- will get access violation if we don't copy tables made in external objects
	local inGameCopy = copyTable(inGameCW)

	Ag.SaveData.Players.inGame = inGameCopy
end

function testWithPlayers(numPlayers)
	local possibleColors = {'Red', 'Purple', 'Green', 'Blue', 'White'}

	local i
	for i = 1, numPlayers do
		table.insert( Ag.SaveData.Players.inGame, possibleColors[i] )
	end
	   createObjectsFromGUIDs() -- depends on number of players
end

function copyTable(table)
	-- tables returned from external objects are protected from access, so need to copy them
	local k, v
	local copy = {}

	for k, v in pairs(table) do
			copy[k] = v
	end

	return copy
end

function spawnScriptingZones()
	-- create scripting zones above all the cards (numPlayers + round)
	local actionSpace
	for _, actionSpace in ipairs(Ag.Cards.InPlay.numPlayerActions) do
		spawnScriptingZone(actionSpace, Ag.ScriptingZones.actionSpaces)
	end

  for _, actionSpace in ipairs(Ag.Cards.InPlay.roundCards) do
		spawnScriptingZone(actionSpace, Ag.SaveData.actionSpaces)
	end
end

function spawnScriptingZone(target, saveLocation)
  local spawnTarget
  -- assume guid if target is a string
  if(type(target) == 'string') then
    spawnTarget = getObjectFromGUID(target)
  else
    -- otherwise it's the object itself
    spawnTarget = target
  end

  local bounds = spawnTarget.getBounds()
  local spawnParams = {
    type = 'ScriptingTrigger',
    position = spawnTarget.getPosition(),
    scale = bounds.size,
    callback_function = function(spawnedObj)
      table.insert(saveLocation, spawnedObj)
    end
  }

  spawnObject(spawnParams)
end

function startGame()
	Ag.SaveData.phase = 'WP' -- Worker Placement
	getObjectFromGUID(Ag.Buttons.passCW).destruct()
	getObjectFromGUID(Ag.Buttons.passCCW).destruct()

	-- wait till cards have spawned before attaching scripts
	while(cardsReady() == false) do
		coroutine.yield(0)
	end
	attachSeedScripts()
	while( Ag.SaveData.Cards.seedScriptsAttached == false) do
		coroutine.yield(0)
	end

	attachPeepScripts()

	deleteDraftIndicators()
	cleanupHands()

	startLuaCoroutine(self, 'startNextRound') -- need Wait api to ensure rounds have spawned
	createNextRoundButton()

	return 1
end

function cardsReady()
	local card
	if(#Ag.SaveData.Players.inGame > 2)  then
		if(Ag.SaveData.Cards.numPlayerActionsSpawned ~= true) then return false end
		for _, card in ipairs(Ag.Cards.InPlay.numPlayerActions) do
			if(card.resting ~= true) then return false end
		end
	end

	if(Ag.SaveData.Cards.roundCardsSpawned ~= true) then return false end
	for _, card in ipairs(Ag.Cards.InPlay.roundCards) do
		if(card.resting ~= true) then return false end
	end

	return true
end

function startNextRound()
	-- wait till cards are ready
	--[[while( cardsReady() == false) do
		coroutine.yield(0)
	end]]

	if(Ag.SaveData.Cards.seedScriptsAttached == false) then
		attachSeedScripts()
	end
	while( Ag.SaveData.Cards.seedScriptsAttached == false) do
		coroutine.yield(0)
	end

	Ag.SaveData.roundNumber = Ag.SaveData.roundNumber + 1

	if(Ag.SaveData.roundNumber > 1) then
		recallPeeps()
	end
	startLuaCoroutine(self, 'flipNextRoundCard')
	startLuaCoroutine(self, 'seedResources')
	--startLuaCoroutine(self, 'splayResources')
	return 1
end

function flipNextRoundCard()
	local roundNum = Ag.SaveData.roundNumber
	--local target = getObjectFromGUID(Ag.SaveData.Cards.InPlay.actionSpaces[roundNum])
  local target = Ag.Cards.InPlay.roundCards[roundNum]
  target.setLock(false)
	target.flip()

	while( isResting(target) ~= true ) do
		coroutine.yield(0) -- wait one frame at a time till safe to lock
	end
	target.setLock(true)

	return 1
end

function seedResources()
	-- wait a few frames while the next round card is still flipping
	coroutine.yield(0) coroutine.yield(0) coroutine.yield(0)

  local numPlayers = #Ag.SaveData.Players.inGame
	local actionSpaces = Ag.SaveData.Cards.InPlay.actionSpaces
  local params = { spawnBoard = Ag.SpawnBoards.Master, infoTable = {} }

  -- * * * * * seed the player cards if 3 or more players * * * * *
  if(numPlayers > 2) then
    params.infoTable = Ag.Cards.PlayerCards[numPlayers]

		-- ensure cards have spawned and are at rest
		while(cardsReady() ~= true) do
			coroutine.yield(0)
		end

		while(Ag.SaveData.Cards.seedScriptsAttached ~= true) do
			coroutine.yield(0)
		end

		local card
    for _, card in ipairs(Ag.Cards.InPlay.numPlayerActions) do
			card.call('seed', params)
		end
  end

  -- * * * * * seed the fishing board (snap points 8-11) * * * * *
  local dayLabBoard = getObjectFromGUID(Ag.Boards.Main.Fishing.guid)
  local snapPoints = dayLabBoard.getSnapPoints()
  local snapOffset = dayLabBoard.getPosition()
  local spawnVectors, spawnRotations = {}, {}
	local i, spawnVector

	-- setup the vectors for placing goods on from 3 wood to Fishing
	for i =8, 11 do
		spawnVector = Game.call('calculateSpawnVector',
			{ snapVector = snapPoints[i],
				offsetVector = snapOffset,
				heightOffset = Ag.HeightOffsets.table
			})
			table.insert(spawnVectors, spawnVector)
			table.insert(spawnRotations, snapPoints[i].rotation)
	end

	local seedList = { {wood = 3}, {clay = 1}, {reed = 1}, {food = 1} }

	-- loop to spawn the seed list
	local good, qty
	for i, data in ipairs(seedList) do
		for good, qty in pairs(data) do
			seedFromSpawnBoard(Ag.SpawnBoards.Master, good, qty, spawnVectors[i], spawnRotations[i].rotation)
		  --coroutine.yield(0) -- pause so multiple goods don't become stack during animation and freeze mid-air
		end
	end

	-- ensure round cards have spawned
	while(Ag.SaveData.Cards.roundCardsSpawned ~= true) do
		coroutine.yield(0)
	end

  -- * * * * * seed round cards up to the current round * * * * *
	params.infoTable = Ag.SaveData.Cards.InPlay.RoundCardData
	local round
  for round = 1, Ag.SaveData.roundNumber do
    --card = getObjectFromGUID(actionSpaces[round])
    Ag.Cards.InPlay.roundCards[round].call('seed', params)
  end
  return 1
end

function seedFromSpawnBoard(spawnBoard, resourceName, qty, vector, rotation)
  local i, bag
  for i = 1, qty do
    spawnBoard[resourceName].takeObject({
      position = vector,
      rotation = rotation,
			smooth = false
    })
  end
end

function placeNumPlayerActions()
	--TODO wait for occs (and minors in sinlge player) to finish spawning

  local numPlayers = #Ag.SaveData.Players.inGame

	if( numPlayers < 3 ) then return 1 end
	local bagGUID = Ag.Bags.playerCards[numPlayers]

	if( bagGUID == nil ) then
    log('placeNumPlayerActions - bag GUID not found')
    return false
  end

	local bag = getObjectFromGUID(bagGUID)
	bag.shuffle()

	local activeBoard = getObjectFromGUID(Ag.Boards.Main.DayLab.guid)
  local activeBoardRotation = activeBoard.getRotation()
	local snapPoints = activeBoard.getSnapPoints()
	local snapOffset = activeBoard.getPosition()

  local cardVector = {}
	local numCards = bag.getQuantity()
  for cardNumber = 1, numCards do
		cardVector[1] = snapOffset.x - snapPoints[cardNumber].position[1]
		cardVector[2] = snapOffset.y - snapPoints[cardNumber].position[2]
		cardVector[3] = snapOffset.z - snapPoints[cardNumber].position[3]
		bag.takeObject( {
			position = cardVector,
      rotation = activeBoardRotation,
			callback_function = function(obj)
				attachSeedScript(obj)
				table.insert(Ag.Cards.InPlay.numPlayerActions, obj)
				obj.setLock(true)
				if(numCards == #Ag.Cards.InPlay.numPlayerActions) then
					Ag.SaveData.Cards.numPlayerActionsSpawned = true
					Wait.condition(lockRoundCards, cardsReady, 5)
				end
			end
		})
	end
	return 1
end

function placeRoundCards()
	randomizeRoundCards()

	-- setup snap info for placement vectors
	local activeBoard = getObjectFromGUID(Ag.Boards.Main.Fishing.guid)
  local activeBoardRotation = activeBoard.getRotation()
	local snapPoints = activeBoard.getSnapPoints()
	local rotation = snapPoints[1].rotation
	local snapOffsets = activeBoard.getPosition()

	local round
	local cardsSpawned = 0 -- replacement for waiting, so we know when all have spawned
	for round, roundData in ipairs(Ag.SaveData.Cards.InPlay.RoundCardData) do
		if(round == 8) then
			activeBoard = getObjectFromGUID(Ag.Boards.Main.EndGame.guid)
      activeBoardRotation = activeBoard.getRotation()
			snapPoints = activeBoard.getSnapPoints()
			rotation = snapPoints[1].rotation
			snapOffsets = activeBoard.getPosition()
		end

		if(round < 8) then snapIndex = round else snapIndex = round - 7 end

		-- setup position vector
		local cardVector = {}
		cardVector[1] = snapOffsets.x - snapPoints[snapIndex].position[1]
		cardVector[2] = snapOffsets.y - snapPoints[snapIndex].position[2] + 1
		cardVector[3] = snapOffsets.z - snapPoints[snapIndex].position[3]

		local stageBag = Ag.Bags.stages[roundData.stage]
		stageBag.takeObject( {
			guid = roundData.guid,
			position = cardVector,
	    rotation = { activeBoardRotation.x, activeBoardRotation.y, 180 },
			callback_function =
				function(card)
	        --card.interactable = false --TODO need to make interactactble if certain cards (e.g. Chamberlain) hit play
					attachSeedScript(card)
	        cardsSpawned = cardsSpawned + 1
					if(cardsSpawned == 14) then
						Ag.SaveData.Cards.roundCardsSpawned = true
					end
				end
		})
	end

	while(Ag.SaveData.Cards.roundCardsSpawned ~= true) do
		coroutine.yield(0)
	end

	roundCardsToObjects()
  destroyTable(Ag.Bags.stages)

	return 1
end

function roundCardsToObjects()
	local roundCardGUIDs = {}
	local card
	for _, card in ipairs(Ag.SaveData.Cards.InPlay.RoundCardData) do
		table.insert(roundCardGUIDs, card.guid)
	end

	local params = {
		isIndexed = true,
		table = roundCardGUIDs
	}

	Ag.Cards.InPlay.roundCards = guidsToObjects(params)
end

function randomizeRoundCards()
	-- want to have an accurate list order for the rounds, without having to wait for them to spawn
	local roundList = {} -- the table we're building
	local stageTracker = 0 -- for knowing when we're on a new bag
	local roundCardsCopy = Game.call( 'copyTable', { table = Ag.Cards.RoundCards } )
	local stageBag, bagSize, stage

	for round = 1, 14 do
		stage = roundToStage(round)

		if(stage > stageTracker) then
			stageBag = Ag.Bags.stages[stage]
			bagSize = stageBag.getQuantity()
			stageBag.shuffle()
			stageTracker = stage
		else
			bagSize = bagSize - 1
		end

		local randomIndex = math.random(1, bagSize)
		table.insert( roundList, table.remove(roundCardsCopy, randomIndex) )
		--roundList[round] = roundCardsCopy[randomIndex]
		--roundCardsCopy = Game.call('removeIndex', { table = roundCardsCopy, index = randomIndex })
	end

	Ag.SaveData.Cards.InPlay.RoundCardData = roundList
end

function destroyGUIDList(table)
  if(table == nil) then return false end

  local guid, obj
  for _, guid in pairs(table) do
    --log('getting guid: ' .. guid)
    obj = getObjectFromGUID(guid)
    obj.destruct()
  end
end

function destroyTable(t)
	local tableSize = Game.call('tableSize', {table = t})
	local i
	for i = 1, tableSize do
		t[i].destruct()
	end
end

function lockRoundCards(bool)
	local bool = bool or true -- default to true with no params
  local card
  for _, card in ipairs(Ag.Cards.InPlay.roundCards) do
    card.setLock(bool)
  end

  for _, card in ipairs(Ag.Cards.InPlay.numPlayerActions) do
    card.setLock(bool)
  end
end

function ulFlipRL(obj, obverse)
	-- unlock, flip, relock

	if(obj == nil) then return end
	if(type(obverse) ~= 'boolean') then obverse = 'ignore' end

	if(obverse == true) then
		if( Game.call('isFaceUp', obj) ) then return end
	elseif(obverse == false) then
		if( Game.call('isFaceUp', obj) ~= true ) then return end
	end

	-- unlock, flip, wait for rest, then relock (prevent mid-air locking)
	obj.interactable = true
	obj.setLock(false)
	obj.flip()

	local handsOff = function()
		obj.setLock(true)
		obj.interactable = false
	end

	local atRest = function()
		return obj.resting
	end

	Wait.condition(handsOff, atRest, 4)
end

function resetNumPlayerActions()
	-- TODO for when draft has started, and Johny come lately rolls in
	local numPlayers = #Ag.SaveData.Players.inGame
	local cardsInPlay = Ag.Cards.InPlay.numPlayerActions
	if (cardsInPlay ~= nil) then
		for _, card in ipairs(cardsInPlay) do
			--TODO place back in appropriate bag
		end
	end
end

function calculateCardPositions()
	local boardName, boardData, offsetTable

	-- go through each board center (boardPosition)
	for boardName, boardData in pairs(Ag.Boards.Main) do
		local activeBoard = getObjectFromGUID(boardData.guid)
		local activeBoardBounds = activeBoard.getBounds()
		local activeBoardCenter = activeBoardBounds['center']
		activeBoardCenter[2] = activeBoardCenter[2] + 0.5

		Ag.Boards.Main[boardName].rotation = activeBoard.getRotation() -- set the rotation dynamically
		local activeBoardScale = activeBoard.getScale()
		local scaleMultiplier = Game.call( 'vectorMath', {t1 = activeBoardScale, t2 = boardData.scale, operator = '/'} )

		--round off differences in scale to 1 (same) if between 0.98 and 1.02
		local multiplier
		local roundedScaleMultiplier = {}
		for _, multiplier in ipairs(scaleMultiplier) do
			if( (multiplier < 1.02) and (multiplier > 0.98) ) then
				table.insert(roundedScaleMultiplier, 1)
			else
				table.insert(roundedScaleMultiplier, multiplier)
			end
		end
		boardData.scaleMultiplier = roundedScaleMultiplier --replace previous division with rounded values if within tolerance

		-- calculate positions based on offsets
		local i
		for i, offsetTable in ipairs(boardData.positionOffsets) do
			local scaleFactoredOffsetTable = Game.call( 'vectorMath', { t1 = offsetTable, t2 = boardData.scaleMultiplier, operator = '*'} )
			--log('* * * SCALE FACTORED OFFSETS * * *')
			--log(scaleFactoredOffsetTable)
			local cardVector = {}

			--log('* * * Ag.Boards.Main[boardName].rotation * * * ')
			--log(Ag.Boards.Main[boardName].rotation)
			if( (Ag.Boards.Main[boardName].rotation[2] >= 180) and (Ag.Boards.Main[boardName].rotation[2] <= 359.99) ) then
				cardVector = Game.call( 'vectorMath', { t1 = activeBoardCenter, t2 = scaleFactoredOffsetTable, operator = '-' } )
			else
				cardVector = Game.call( 'vectorMath', { t1 = activeBoardCenter, t2 = scaleFactoredOffsetTable, operator = '+' } )
			end

			table.insert(boardData.cardPositions, cardVector)

			-- also create corresponding x,y,z indexes for 1,2,3 respectively
			local xyzIndex = Game.call('vectorNumberToLetter', i)
			if(xyzIndex ~= nil) then boardData.cardPositions[xyzIndex] = cardVector end
		end
	 end
end

function onChangedHandSize()
  printToAll('Hand Size Set!')
end

function attachSeedScripts()
	local card
	for _, cardSet in pairs(Ag.Cards.InPlay) do
		for _, card in ipairs(cardSet) do
			attachSeedScript(card)
		end
	end

	Ag.SaveData.Cards.seedScriptsAttached = true
end

function attachSeedScript(card)
	local commonScript = [===[
	 splayGrid = {} -- 3x3 grid for making resources visible w/o mouseover

	 function onload()
		 Game = getObjectFromGUID('40398f')
		 seededGoods = 0 -- track number of goods on this card (not counting card effects)
	 end

	 function seed(params)
     local spawnBoard = params.spawnBoard
     local infoTable = params.infoTable

		 if(#splayGrid == 0) then splayGrid = calculateSplayGrid(3, 3) end

     local cardRotation = self.getRotation()
     local guid = self.getGUID()

     local info
     for _, info in pairs(infoTable) do
       -- search for this cards guid
       if( info.guid == guid ) then
         -- grain and veg don't get seeded here
         if( info.name ~= 'grain' and info.name ~= 'veg') then
           if( spawnBoard[info.name] ~= nil ) then
						 if(info.name == 'food') then
						 	--log(splayGrid)
						 end
             -- spawn the appropriate quantity if seeding player card
             local numLoops = info.qty or 1
						 --local numLoops = 1

						 -- * * * code for when not splaying * * *
             local destinationVector = self.getPosition()
             destinationVector.y = destinationVector.y + 2.2

             for numGoods = 1, numLoops do
							 seededGoods = seededGoods + 1
							 --log(seededGoods)
							 --log('splayGrid dest:')
							 --log(splayGrid[seededGoods])
               spawnBoard[info.name].takeObject({
            	    position = destinationVector,
									--position = splayGrid[seededGoods],
                  rotation = {cardRotation.x, cardRotation.y, cardRotation.z + 30},
									smooth = false,
									callback_function = function(obj)
										obj.use_snap_points = false
										--obj.setLock(true)
									end
                })
              end
            end -- spawnBoard ~= nil
          end -- not grain or veg
        end  -- matched guid
      end -- for loop
    end -- function

		function calculateSplayGrid(width, height)
			local returnGrid = {}
			local p = self.getPosition()
			local nb = self.getBoundsNormalized()
			--local gapDistance = (nb.size.x / (width + 1)) / 1.5
			local gapDistance = nb.size.x / (width + 1)
			local leftEdge = p.x - (nb.size.x / 2)
			--log('leftEdge:')
			--log(leftEdge)

			-- start on the top left, and track new positions with gridVector
			local leftGridEdge = leftEdge + gapDistance
			--log('gapDist: ' .. gapDistance)
			--leftGridEdge[1] =  leftGridEdge[1] + gapDistance -- have one gap unit distance on each edge
			heightOffset = 0.2
			--local gridVector = { x = leftGridEdge, y = heightOffset + p.y, z = p.z - (nb.size.z / 2) + 0.8 }
			--local gridVector = { x = leftGridEdge, y = heightOffset + p.y, z = p.z }
			--gridVector = Game.call('copyTable', { table = gridVector })

			local w, h
			for h = 1, height do
				for w = 1, width do
					--local vectorCopy = Game.call('copyTable', { table = gridVector })
					local gridSize = #returnGrid
					if(gridSize == 0) then returnGrid[1] = { x = leftGridEdge, y = heightOffset + p.y, z = p.z }
					else
						local nextGridPoint = {}

						-- new row
						if(w == 1) then
							 nextGridPoint.x = leftGridEdge
							 nextGridPoint.z = returnGrid[gridSize].z + (1.2 * gapDistance)
						else
							 nextGridPoint.x = returnGrid[gridSize].x + gapDistance
							 nextGridPoint.z = returnGrid[gridSize].z
						end
						nextGridPoint.y = returnGrid[gridSize].y

						table.insert(returnGrid, vectorCopy)
					end

					--gridVector[1] = Game.call('copyValue', { value = gridVector[1] }) + gapDistance
					--gridVector[2] = initialHeight + ( 0.2 * w )
					--log('after adding:')
					--log(gridVector[1])
				end
			end
			return returnGrid
		end
	]===]

  if(card ~= nil) then
    card.setLuaScript(commonScript)
  else
    log('Error Global:attachCardScripts - target card is null')
  end
	--[[local card

	for _, cardSet in pairs(Ag.Cards) do
		for _, cardGUID in pairs(cardSet) do
			card = getObjectFromGUID(cardGUID)
			if(card ~= nil) then card.setLuaScript(seedCardScript) end
		end
	end]]
end

function refreshPlayerBoardPositions()
	local color, guid

	for color, guid in pairs(Ag.Boards.Players) do
		local board = getObjectFromGUID(guid)
		if(board ~= nil) then
			local position = board.getPosition()
			local rotation = board.getRotation()
			Ag.Players.homePositions[color] = position
			Ag.Players.homeRotations[color] = rotation
		end
	end
end

function roundToStage(round)
	if( (round >= 1) and (round <= 4) ) then return 1
	elseif( (round >= 5 ) and (round <=7 ) ) then return 2
	elseif( (round >= 8 ) and (round <= 9 ) ) then return 3
	elseif( (round >= 10 ) and (round <= 11 ) ) then return 4
	elseif( (round >= 12 ) and (round <= 13 ) ) then return 5
	elseif(round == 14 ) then return 6
	else return 0 end
end

function isPeepContainer(guid)
	-- returns the player color of the peep container (spawn board)
	-- this came from, or false

	for color, data in pairs(Ag.SpawnBoards.Players) do
		if(data['peepBag'] == guid) then return color end
	end
	return false
end

function onPeepSpawned(params)
	table.insert(Ag.SaveData.Players.peeps[params.color], params.guid)
	--log(Ag.SaveData.Players.peeps)
end

-- bring peeps back to homes at the start of a new round
function recallPeeps()
	refreshPlayerBoardPositions()

	local color, peepGUID, peepObj
	for _, color in ipairs(Ag.SaveData.Players.inGame) do
		--if(Ag.peeps[color] ~= nil) then
		for _, peepGUID in pairs(Ag.SaveData.Players.peeps[color]) do
			peepObj = getObjectFromGUID(peepGUID)
			if( peepObj ~= nil) then
				Ag.Players.homePositions[color].y = Ag.Players.homePositions[color].y + 2.5
				peepObj.setPositionSmooth(Ag.Players.homePositions[color], false, false)
			end
				--peepPosition = peepObj.getPosition()
				--if(peepPosition[1] > -42) then
				--log(color..' peep '..peepGUID..' needs to come home!')
				--log(color..' peep '..peepGUID..' is at '..peepPosition[1]..', '..peepPosition[2]..', '..peepPosition[3])
				--end
		end
	end
end

function onClickRotateDraftCW()
  flipDraftIndicators()
    local players = getRealSeatedPlayers()
    local playersClockwise = playersClockwise(players)
    --log('DEBUG: Number of seated players: ' .. #players)
    --log('DEBUG: Number of players clockwise: ' .. #playersClockwise)
    --for i,player in ipairs(playersClockwise) do
    --    log('DEBUG: ' .. i .. ' : ' .. player.color)
    --end
    for i, player in ipairs(playersClockwise) do
        local moveToIndex = 1
        if i == #players
        then
            moveToIndex = 1
        else
            moveToIndex = i + 1
        end
        local moveToPlayer = playersClockwise[moveToIndex]
        --log('DEBUG: Moving cards from ' .. i .. ' : ' .. player.color ..
        --    ' to ' .. moveToIndex .. ' : ' .. moveToPlayer.color)
        for i,card in ipairs(player.getHandObjects()) do
      			card.setPosition(getPlayerHandPosition(moveToPlayer))
      			card.setRotation({0, moveToPlayer.getHandTransform(1).rotation[2]+180, 0})
    		end
    end
end

function onClickRotateDraftCCW()
  flipDraftIndicators()
    local players = getRealSeatedPlayers()
    local playersCounterClockwise = playersCounterClockwise(players)
    --log('DEBUG: Number of seated players: ' .. #players)
    --log('DEBUG: Number of players clockwise: ' .. #playersClockwise)
    --for i,player in ipairs(playersClockwise) do
    --    log('DEBUG: ' .. i .. ' : ' .. player.color)
    --end
    for i, player in ipairs(playersCounterClockwise) do
        local moveToIndex = 1
        if i == #players
        then
            moveToIndex = 1
        else
            moveToIndex = i + 1
        end
        local moveToPlayer = playersCounterClockwise[moveToIndex]
        --log('DEBUG: Moving cards from ' .. i .. ' : ' .. player.color ..
        --    ' to ' .. moveToIndex .. ' : ' .. moveToPlayer.color)
        for i,card in ipairs(player.getHandObjects()) do
            card.setPosition(getPlayerHandPosition(moveToPlayer))
      			card.setRotation({0, moveToPlayer.getHandTransform(1).rotation[2]+180, 0})
        end
    end
end

function flipDraftIndicators(flipDestination)
	-- ensure all the counters are at rest
	function atRest()
		return isTableResting({ table = Ag.Players.draftIndicators })
	end

	function flip()
		local color, draftIndicator, rotation
		for color, draftIndicator in pairs(Ag.Players.draftIndicators) do
			rotation = draftIndicator.getRotation()
			if(draftIndicator ~= nil) then
				if(flipDestination == 'x') then
					if( (rotation.z > -5) and (rotation.z < 5) ) then
						ulFlipRL(draftIndicator)
					end
				elseif(flipDestination == 'check') then
					if( (rotation.z > 175) and (rotation.z < 185) ) then
						ulFlipRL(draftIndicator)
					end
				end
			end -- ~= nil
		end -- for
	end -- flip()

	Wait.condition(flip, atRest, 5)
end

function waitFrames(frames)
  while frames > 0 do
      coroutine.yield(0)
      frames = frames - 1
  end
end

function allPlayersDrafted()
	--startLuaCoroutine(Global, 'waitThirtyFrames')

	--log(Ag.SaveData.Players.DraftPicks)
	for _, playerColor in ipairs(Ag.SaveData.Players.inGame) do
		--local picksMade = Ag.SaveData.Players.DraftPicks[playerColor]
		--if(picksMade == nil) then return false end
		--if(Ag.SaveData.Cards.Draft.pickNumber ~= #picksMade) then return false end
		if(readyForPass(playerColor) ~= true) then return false end
	end
	return true
end

function readyForPass(color)
	-- draft indicator needs to account for someone dragging card to draft zone,
	-- then putting back after pass, then pulling back again
	local picksMade = Ag.SaveData.Players.DraftPicks[color]
	if(picksMade == nil) then	return false end
	if(Ag.SaveData.Cards.Draft.pickNumber ~= #picksMade) then
		log(Ag.SaveData.Cards.Draft.pickNumber)
		log(#picksMade)
		return false
	end
	return true
end

function isPeep(obj)
	local name = obj.getName()

	-- peeps are named for the color of the player they are
	--local inGame = Game.call('inTable', { table = Ag.SaveData.Players.inGame, searchValue = name })
	local legalColor = Ag.Boards.Players[name] ~= nil
	if(legalColor) then
		return name
	else
		return false
	end
end

function attachPeepScripts()
	-- attach scripts to starting peeps (avoiding file bloat by having the code already on them)
	local color
	for _, color in ipairs(Ag.SaveData.Players.inGame) do
		local guid
		for _, guid in ipairs(Ag.SaveData.Players.peeps[color]) do
			local peep = getObjectFromGUID(guid)
			attachPeepScript(peep, color)
		end
	end
end

function attachPeepScript(obj, color)
	-- attaches the script to a single peep
	local peepScript = [===[
		function onload()
			broadcastAfterSpawn()
		end

		function broadcastAfterSpawn()
			if(self.spawning == true) then
				Wait.frames(broadcastAfterSpawn, 1)
			else
				Global.call('onPeepSpawned', { guid = self.getGUID(), color = ']===] .. color .. [===['} )
			end
		end
	]===]

	obj.setLuaScript(peepScript)
end

-- * * * GLOBAL LISTENERS (events that fire automatically) * * *
function update()
	--[[ The Update function. This is called once per frame. --]]
end

function onSave()
	--return ''
	--Game.call('dumpTable', { table = Ag.SaveData, maxFields = 3 } )
  --return ''  --Remove -- at start & save to clear save data
  --return JSON.encode(Ag.SaveData) -- CAN'T SAVE TABLES WITH NUMERIC AND STRING KEYS
end

function onObjectEnterScriptingZone(zone, obj)
	if(Ag.SaveData.phase == 'draft') then
		table.insert(Ag.Cards.draftActionQueue, { zone = zone, obj = obj })
		startLuaCoroutine(self, 'onDraftActionTaken')
	end
end

function onDraftActionTaken()
	--log('entered onDraftActionTaken')
	local queue = Ag.Cards.draftActionQueue
	-- in the event of multiple rapid requests, we make them wait in line
	while(#queue > 1) do
		coroutine.yield(0)
	end
	--log('done waiting')

	local obj = queue[1].obj
	local objGUID = obj.getGUID()
	local zone = queue[1].zone
	local zoneGUID = zone.getGUID()

	local matchingColor = ''
	-- * * * WHEN CARD HITS DRAFT AREA * * *
	if(Ag.SaveData.phase == 'draft') then
		-- iterate the player hand zones and see if an object left their hand
		local color, handGUID, wasReady
		for color, handGUID in pairs(Ag.ScriptingZones.Players.Draft) do
			if(zoneGUID == handGUID) then
				log('current history')
				log(Ag.SaveData.Players.DraftPicks[color])
				matchingColor = color
				-- save status of whether they were previously ready to pass cards
				wasReady = readyForPass(matchingColor)

				-- add the card to draft history
				local draftPicks = Ag.SaveData.Players.DraftPicks
				if(draftPicks[color] == nil) then draftPicks[color] = { objGUID }
				elseif(Game.call('inTable', { table = draftPicks, searchValue = objGUID }) == false) then
					-- make sure haven't drafted this card yet (rapid back and forth may trigger)
					table.insert(draftPicks[color], objGUID)
				end

				-- check if we have too many cards, and pop the previously taken card back
				if( #draftPicks[color] > Ag.SaveData.Cards.Draft.pickNumber ) then
					--local returningCardGUID = draftPicks[color][#draftPicks[color] - 1]
					--local returningCard = getObjectFromGUID(returningCardGUID)
					local handObject = getObjectFromGUID(Ag.ScriptingZones.Players.Hands[color])
					--log(handObject)
					local positionVector = handObject.getPosition()
					--TODO returningCard.setPositionSmooth(positionVector, false, false)
					obj.setPosition(positionVector)
					--remove all occurances
					local i, guid
					local removeList = {}
					for i, guid in draftPicks[color] do
						if(guid == objGUID) then
							table.insert(removeList, i)
						end
					end
				end

				while(#removeList > 0) do
					local removeIndex = removeList[#removeList]
					table.remove(draftPicks[color], removeIndex)
					table.remove(removeList, #removeList)
				end

				-- check for accurate hand size, because #usersBreakThings
				local di = Ag.Players.draftIndicators[color]
				if(readyForPass(color)) then
					if( allPlayersDrafted() ) then
						startLuaCoroutine(self, 'nextDraftStep')
					end
				end
				--log('picks for ' .. color)
				--log(draftPicks[color])
				break
			end -- matching draft zone
		end

		-- if any card hits the * * * HANDs * * * zone that is already in their draft list,
		-- then put the card back in their draft area
		if(matchingColor == '') then
			for color, handGUID in pairs(Ag.ScriptingZones.Players.Hands) do
				if(zoneGUID == handGUID) then
					matchingColor = color

					local draftPicks = Ag.SaveData.Players.DraftPicks[color]
					if(draftPicks ~= nil) then
						-- check if card is in draft history
						if( Game.call('inTable', {table = draftPicks, searchValue = objGUID}) == true) then
							-- make sure it's the most recent card
							local mostRecentDraftGUID = draftPicks[#draftPicks]
							log(mostRecentDraftGUID)
							if (mostRecentDraftGUID == objGUID) then
								-- flip indicator

							else
								local handObject = getObjectFromGUID(Ag.ScriptingZones.Players.Draft[color])
								local positionVector = handObject.getPosition()
								log(positionVector)
								local returningCard = getObjectFromGUID(objGUID)
								--returningCard.setPositionSmooth(positionVector, false, false)
								returningCard.setPosition(positionVector)
								printToColor('Please draft another card,\nyour previous pick will be returned.',
								color)
							end
						end
					end
					--log('picks for ' .. color)
					--log(draftPicks[color])
					break
				end -- matching hand
			end
		end

		-- set the indicator the correct way
		if(matchingColor ~= '') then
			local di = Ag.Players.draftIndicators[matchingColor]
			local readyNow = readyForPass(matchingColor)
			local playerName = Player[matchingColor].steam_name or matchingColor

			ulFlipRL(di, readyNow)

			-- indicate who has made a pick, or who is changing mind
			if( (wasReady == true) and (readyNow == false) ) then
				printToAll(playerName .. ' is having second thoughts...')
			elseif( (wasReady == false) and (readyNow == true) ) then
				printToAll(playerName .. ' is ready to pass.')
			end
		end
	end

	-- pop the first item in our queue (first in, first out)
	table.remove(queue, 1)

	return 1
end

function onObjectLeaveScriptingZone(zone, obj)
	local objGUID = obj.getGUID()
	local zoneGUID = zone.getGUID()
	--[[
		if(Ag.SaveData.phase == 'draft') then
			-- iterate the player hand zones and see if an object left their hand
			local color, handGUID, foundZone
			for color, handGUID in pairs(Ag.ScriptingZones.Players.Draft) do
				--log('searching for card leaving zone: ' .. handGUID)
				if(zoneGUID == handGUID) then
					printToAll(color .. ' is having second thoughts...')
					local di = Ag.Players.draftIndicators[color]
					ulFlipRL(di)
					local draftPicks = Ag.SaveData.Players.DraftPicks[color]
					if(draftPicks ~= nil) then table.remove(draftPicks, #draftPicks) end
				end
			end
		end]]
end

function onObjectDestroy(obj)
	local guid = obj.getGUID()

	-- check if we're deleting a family member
	local isPeep = Game.call('inTable', { table = Ag.SaveData.Players.peeps, searchValue = guid } )
	if(isPeep) then
		deleteInTable( { table = Ag.SaveData.Players.peeps, searchValue = guid } )
		--table.remove(Ag.SaveData.Players.peeps, guid)
		--log(Ag.SaveData.Players.peeps)
	end
end

function onObjectLeaveContainer(container,  obj)
	-- WARNING obj.guid will be wrong, because it hasn't spawned yet!!!

	local peepColor = isPeepContainer(container.getGUID())
	if(peepColor ~= false) then attachPeepScript(obj, peepColor) end
end

function onObjectSpawn(spawnObj)
	local peepColor = isPeep(spawnObj)
	if( peepColor ~= false ) then
		--onPeepSpawned( { color = peepColor, guid = spawnObj.getGUID() } )
	end
end

-- * * * From Game Object (things that break because of userdata violations)
function guidsToObjects(params)
	-- take a indexed table of guids and return a table of corresponding objects
	local t = params.table
	local isIndexed = params.isIndexed
	local returnTable = {}

	if( t == nil ) then
		log('error guidsToObj_indexed: table is nil')
		return nil
	end

	if(isIndexed) then
		for _, guid in ipairs(t) do
			if( type(guid) ~= 'string' ) then
				log('error guidsToObj_indexed: guid is not a string')
			else
				returnTable[#returnTable + 1] = getObjectFromGUID(guid)
			end
		end
	else
		local key
		for key, guid in pairs(t) do
			if( type(guid) ~= 'string' ) then
				log('error guidsToObj_indexed: guid is not a string')
			else
				returnTable[key] = getObjectFromGUID(guid)
			end
		end
  end

	return returnTable
end

function setTableProps(params)
	-- iterate over a table of objects and set all properties
	local t = params.table
	local props = params.props
	local obj, property, value

	for _, obj in pairs(t) do
		-- if given a string, assume it's a guid
		if( type(obj) == 'string' ) then
			obj = getObjectFromGUID(obj) -- try to grab the object
			if( obj == nil ) then
				log('error setTableProps: expecting object or guid')
				return false
			end
		end

		for property, value in pairs(props) do
			obj[property] = value
		end
	end
end

function isResting(obj)
	return obj.resting
end

function isTableResting(params)
	local t = params.table

	for _, obj in pairs(t) do
		if(obj.resting ~= true) then return false end
	end
	return true
end

function deleteInTable(params)
  -- delete all occurances of a given value within a table
  -- works recursively
  local t = params.table
  local searchValue = params.searchValue

  -- return false if table is nil
  if(t == nil) then return nil end

  local k, v
  --log('searching for value: ' .. searchValue)
  for k, v in pairs(t) do
    --log('parsing value: ' .. v)
    if( type(v) == 'table') then
      v = deleteInTable( { table = v, searchValue = searchValue } )
      t[k] = v
    elseif( v == searchValue ) then
      table.remove(t, k)
    end
  end

  return t
end

-- * * * TEST BUTTONs * * *
function onClickTestButton(obj, player_clicker_color)
  testWithPlayers(4)
	setupCards()
	assembleProxyBags()
	dealCards('occs')
	Ag.Cards.occsDealt = true
	--dealCards('minors')
	--startLuaCoroutine(self, 'startDraft')
	--startLuaCoroutine(self, 'startDraft')
  --startLuaCoroutine(self, 'startGame')
end

function onClickTestButtonTwo(obj, player_clicker_color)
	testWithPlayers(5)
	assignStartPlayer()
	--assembleProxyBags()
	--dealFromProxyBag(Ag.SaveData.Cards.ProxyOccBag, Ag.SaveData.Cards.initialHandSize, Ag.SaveData.Zones.MainHands)
end
