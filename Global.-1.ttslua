function onload(saveState)
	Game = getObjectFromGUID('40398f') -- general helper object for common tasks

	Ag = {
		Bags = {
			decks = { E = '9eb064', I = '47d57c', K = '9e3d4c', WM = '28b771', FR = '8afe39',
								G = 'fb6a79', C = 'a4d426', FL = 'c54cb9', WA = '0b6410'},

			playerCards = {},
			occs = '8fc8a5', -- actual occs this game, after the selected decks have been assembled
			minors 			= '63ceb8'	-- actual minors this game, after the selected decks have been assembled
		},
		Boards = {
			Players = { Red = '7c4084', Purple = 'd349b2', Green = '454b89', Blue = '858dea', White = '179cb5' },

			--TODO implement accounting for board resize when calculating seed positions
			Main = {
				DayLab = {
					cardPositions = {},
					guid = '78928b',
					-- -1, 5.2, 2.92
					positionOffsets = { {3.202, 0, -4.35}, {0.282, 0, -4.35}, {3.202, 0, 0},
															{0.282, 0, 0}, {3.202, 0, 4.531}, {0.282, 0, 4.531} },
					rotation = {},
					scale = {6.92, 1.00, 6.92},
					scaleMultiplier = {}
				},

				Fishing = {
					cardPositions = {},
					guid = 'e7d3f6',
					positionOffsets = {
						{-3.33, 0, -7.72}, {-0.17, 0,5.83}, {-0.17, 0,0.05},
						{-0.17,0,-4.54}, {3.06,0,4.24}, {3.06,0,-0.04}, {3.06, 0, -4.54}
					},
					rotation = {},
					scale = {6.92, 1.00, 6.92},
					scaleMultiplier = {}
				},

				EndGame = {
					cardPositions = {},
					guid = '375a44',
					positionOffsets = {
						{4.97,0,2.3}, {-4.32,0,-1.95}, {-1.75,0,2.26},
						{-1.75,0,-2.07}, {1.55,0,2.3}, {1.55,0,-2.21}, {4.48,0,2.3}
					},
					rotation = {},
					scale = {4.91, 1, 4.91},
					scaleMultiplier = {}
				},
			},
		},
		Buttons = { dealCards ='809d48' },
		Cards = {
			beggars 		= 'f28a11',
			heightOffset = 0.15, -- for dropping cards above snap points
			loadedOccs = {},
			loadedMinors = {},
			roundCards 	= { sheep = '85b867', majorMinor = 'cda9b3', fences = 'e5f7cd', sowBake = '8eeb11', fg = 'bded46',
										 stoneStage2 = '0d7a31', renoMajor = 'c8762e', boar = '6c1287', veg = '202efb', cattle = '1e18f2',
										 stoneStage4 = 'd37bf8', plowSow = '1a8ef8', fgWithoutSpace = '618af7', renoFence = 'a1e455'},
			stages 			= { 'e76b68', 'bd32c0', '25abf3', '128b47', 'ea78f6', 'a1e455' } -- 1-6, respectively
		},
		Draft = { indicators = { Purple = "b57b80", Green = "80bcd4", Blue = "1c4ce5", White = "76cb43", Red = "abf3a9" } },
		Players = {
			homePositions = {},

			--TODO populate dynamically with GUIDs from spawn board
			peeps = { Purple = {'75d6bb', '8f914b', 'db306d', 'eb883c', 'f38a90'},
								Red = {'1145a1', 'bdefda', 'd291e4', '7aa697', '445dad'},
								Brown = {'063ea8', '0504ab', '60361a', 'e1cb00', '35b950'},
								Green = {'5ed89f', 'e082a2', 'fcd09c', 'b46095', 'e3f486'},
								Blue = {'98536c', '182092', 'c3ee56', '578516', '6bce00'} },
		},
		SaveData = {
			Cards = {
				initialHandSize = 7,
				InPlay = { numPlayerActions = ''}
			},
			Players = { inGame = {} },
			roundNumber = 1
	 },
		ScriptingZones = { deckSelectButtons = '8b293c', occs = '346893', minors = '392c2f' },
		SelectedDecks = {},
		SpawnBoard = {
			master = {
				food = getObjectFromGUID('8e8091'), grain = getObjectFromGUID('2459f4'), veg = getObjectFromGUID('391c13'),
				wood = getObjectFromGUID('c4d916'), clay = getObjectFromGUID('4e06e8'),  stone = getObjectFromGUID('fe3238'),
				reed = getObjectFromGUID('9c217a'), sheep = getObjectFromGUID('ca7c6c'), pig = getObjectFromGUID('d02a32'),
				cow = getObjectFromGUID('ee948a') }
		},
		Style = { broadcastTint = {200/255,1,200/255} },
		Tiles = { occ = '756dc7', minor = '2812f4'}
	}

	Ag.Bags.playerCards[3] = 'b4aad8'
	Ag.Bags.playerCards[4] = 'eb2550'
	Ag.Bags.playerCards[5] = '6fd961'

	Ag.Cards[3] = { clay = 'c2aaf9', wood2 = '11e22f', anyResource = '706011', occ = 'bc4db6' }
	Ag.Cards[4]	= { clay2 = '37a094', wood2 = 'aadc49', wood = '91aa89', gSpot = '2ee1f1', occ = '2a1d9a', tp = '2a1d9a' }
	Ag.Cards[5] = { clay3 = '1316e0', wood4 = '470341', zoo = 'b438d7', gSpot = '4db587', occ = 'd4d96d', tp = 'c8734c' }

	if( saveState ~= "") then
    Ag.SaveData = JSON.decode(saveState)
		log('loaded save data')
		log('current round: ' .. Ag.SaveData.roundNumber)
	end
	createDealButton()
  --UI.setAttribute("dealButtons", "active", false)
  --UI.setAttribute("dealLayout", "height", 40)
	--startLuaCoroutine(Global, 'createDealButton')
	--calculateCardPositions()

	--TODO place this after cards are seeded
	--attachCardScripts() -- attach scripts to seed goodies, or whatevs in the future

  --setup_button = setup()
  --minors_button = minors_setup()
  --occs_button = occs_setup()
end

function onSave()
    return ""  --Remove -- at start & save to clear save data
    --return JSON.encode(Ag.SaveData)
end

function update()
	--[[ The Update function. This is called once per frame. --]]
  --[[ log('Update loop!') --]]
end

function createDealButton()
	local dealButton = getObjectFromGUID(Ag.Buttons.dealCards)

	--local button = getObjectFromGUID(Ag.Buttons.startDraft)
  local params = {
		--click_function = 'onClickAssembleDecks("draft")',
		click_function = 'onClickDealCards',
	  position = {0, 0, 0},
	  width = 900,
	  height = 900
	}
  dealButton.createButton(params)
end

function onClickDealCards()
	getPlayers()
	local numPlayers = #Ag.SaveData.Players.inGame

	if(numPlayers == 0) then
		broadcastToAll('Agricola plays 1-5 players!\n Click your name in the top right and select "Change Color".', Ag.Style.broadcastTint)
	elseif( (numPlayers > 0) and (numPlayers < 6) ) then
		startLuaCoroutine(Global, 'assembleDecks')
		--assembleDecks()
		startLuaCoroutine(Global, 'startGame')
		if(numPlayers == 1) then broadcastToAll('Starting solo game', Ag.Style.broadcastTint)
		else broadcastToAll('Starting game with ' .. numPlayers .. ' players', Ag.Style.broadcastTint) end
	else
		broadcastToAll('Wow, ' .. numPlayers .. ' players want to play, but max 5 players!', Ag.Style.broadcastTint)
	end
end

function assembleDecks()
	--local numPlayers = #Ag.SaveData.Players.inGame
	local numPlayers = 4
	local buttonZone = getObjectFromGUID(Ag.ScriptingZones.deckSelectButtons)
	local deckButtons = buttonZone.getObjects() -- Zone.getObjects() returns {Object, ...}
	local selectedDecks, sortedDecks, chosenDecks = {}, {}, {}
	local deckButton

	for _, deckButton in ipairs(deckButtons) do
		if( deckButton.getStateId() == 1) then
			table.insert( chosenDecks, deckButton.getName() )
		end
	end
	Ag.selectedDecks = chosenDecks

	if( Ag.selectedDecks == nil) then
		broadcastToAll("Please select at least one deck.\nHover over the deck buttons and press '1' to add, or '2' to remove.", Ag.Style.broadcastTint)
	elseif( #(Ag.selectedDecks) >= 1 ) then
		local params = { unorderedTable = chosenDecks, orderedTable = Ag.Bags.decks }
		sortedDecks = Game.call('matchTableKeyOrder', params)

		local minorTile = getObjectFromGUID(Ag.Tiles.minor)
		local minorTileVector = minorTile.getPosition()
		minorTileVector.y = minorTileVector.y + Ag.Cards.heightOffset

		local occTile = getObjectFromGUID(Ag.Tiles.occ)
		local occTileVector = occTile.getPosition()
		occTileVector.y = occTileVector.y + Ag.Cards.heightOffset

		local broadcastString = 'Decks in Play: '
		local deckName, i
		local lastDeck = sortedDecks[#sortedDecks]

		for i, deckName in ipairs(sortedDecks) do
			local destinationMinorBag = getObjectFromGUID(Ag.Bags.minors)
			--local destinationMinorBagPosition = destinationMinorBag.getPosition()
			local destinationOccBag = getObjectFromGUID(Ag.Bags.occs)
			--local destinationOccBagPosition = destinationOccBag.getPosition()
			local deckBag = getObjectFromGUID(Ag.Bags.decks[deckName])

			-- assemble the minors
			deckBag.takeObject({
				position = minorTileVector,
				callback_function =
				function(cards)
					if(#Ag.Cards.loadedMinors == #sortedDecks) then
						--cards.flip() 
					end
				end
			})

			-- assemble the +1 occs
			deckBag.takeObject({
				position = occTileVector,
				callback_function = function(cards)
					if(numPlayers > 2) then -- optionally assemble the +3 occs
						deckBag.takeObject({
							position = occTileVector,
							callback_function = function(cards)
								if( (numPlayers > 3) and (deckName ~= 'WM')) then -- optionally assemble the +4 occs (WM deck only has 1+ and 3+)
									deckBag.takeObject({
										position = occTileVector,
										callback_function =
										function(cards)
											table.insert(Ag.Cards.loadedOccs, deckName)
											if(#Ag.Cards.loadedOccs == #sortedDecks) then dealCards('occs') end
										end
									}) -- 4+ takeObject
								else
									table.insert(Ag.Cards.loadedOccs, deckName)
									if(#Ag.Cards.loadedOccs == #sortedDecks) then dealCards('occs')	end
								end -- 3+
							end
						})
					else
						table.insert(Ag.Cards.loadedOccs, deckName)
						if(#Ag.Cards.loadedOccs == #sortedDecks) then dealCards('occs') end
					end
				end
			}) -- 1+ takeObject

			if(i == 1) then broadcastString = broadcastString .. deckName
			else broadcastString = broadcastString .. ', ' .. deckName end
		end
		broadcastToAll(broadcastString, Ag.Style.broadcastTint)

		--wait some time so decks can properly spawn before dealing
		--broadcastToAll('Loading deck images...', Ag.Style.broadcastTint)
		--broadcastToAll('waiting is over!', Ag.Style.broadcastTint)
	end
	return 1
end

function getPlayers()
	local inGame = {}
	inGame = Game.call('playerSnapshot')

	local inGameCopy = copyTable(inGame)
	Ag.SaveData.Players.inGame = inGameCopy
end

function copyTable(table)
	-- tables returned from external objects are protected from access, so need to copy them
	local k, v
	local copy = {}

	for k, v in pairs(table) do
			copy[k] = v
	end

	return copy
end

function dealCards(cardType)
	local zone = getObjectFromGUID(Ag.ScriptingZones[cardType])
	local zoneObjects = zone.getObjects()
	local cardStack = zoneObjects[1]
	log(cardStack)
	cardStack.flip()
	cardStack.shuffle()
	cardStack.deal(7)

	--occBag.deal(Ag.SaveData.initialHandSize)
	--for _, color in ipairs(g.SaveData.Players.inGame) do
	--	Player[color].
	--end
	return 1
end

function startGame()
	local numPlayers = #Ag.SaveData.Players.inGame
	--placeNumPlayerActions(numPlayers)

	--calculateCardPositions()
	--placeRoundCards()

	return 1 -- coroutine necessity
end

function placeNumPlayerActions(numPlayers)
	local bagGUID = Ag.Bags.playerCards[numPlayers]

	if( bagGUID ~= nil ) then
		local bag = getObjectFromGUID(bagGUID)
		bag.shuffle()

		local activeBoard = getObjectFromGUID(Ag.Boards.Main.DayLab.guid)
		local snapPoints = activeBoard.getSnapPoints()
		local snapOffset = activeBoard.getPosition()

		local cardNumber = 1
		while( bag.getQuantity() > 0 ) do
			local cardVector = {}
			cardVector[1] = snapOffset.x - snapPoints[cardNumber].position[1]
			cardVector[2] = snapOffset.y - snapPoints[cardNumber].position[2] + 1
			cardVector[3] = snapOffset.z - snapPoints[cardNumber].position[3]
			local card = bag.takeObject( { position = cardVector } )
			table.insert(Ag.SaveData.Cards.InPlay.numPlayerActions, card)
			cardNumber = cardNumber + 1
			--Game.call('waitFrames', 15)
		end
	end
	return 1
end

function resetNumPlayerActions()
	local numPlayers = #Ag.SaveData.Players.inGame
	local cardsInPlay = Ag.SaveData.Cards.InPlay.numPlayerActions
	if (cardsInPlay ~= nil) then
		for _, card in ipairs(cardsInPlay) do
			--TODO place back in appropriate bag
		end
	end
end

function nextRound()
	flipRoundCard()
end

function placeRoundCards()
	local activeBoard = getObjectFromGUID(Ag.Boards.Main.Fishing.guid)
	local snapPoints = activeBoard.getSnapPoints()
	local rotation = snapPoints[1].rotation
	local snapOffsets = activeBoard.getPosition()

	local round, stage, snapIndex
	for round = 1, 13 do
		-- update board from round 8 onwards
		if(round == 8) then
			activeBoard = getObjectFromGUID(Ag.Boards.Main.EndGame.guid)
			snapPoints = activeBoard.getSnapPoints()
			--log(snapPoints)
			rotation = snapPoints[1].rotation
			snapOffsets = activeBoard.getPosition()
		end

		if(round < 8) then snapIndex = round else snapIndex = round - 7 end

		stage = roundToStage(round)
		local cardPile = getObjectFromGUID(Ag.Cards.stages[stage])

		local cardVector = {}
		cardVector[1] = snapOffsets.x - snapPoints[snapIndex].position[1]
		cardVector[2] = snapOffsets.y - snapPoints[snapIndex].position[2] + 1
		cardVector[3] = snapOffsets.z - snapPoints[snapIndex].position[3]

		cardPile.shuffle()
		local card = cardPile.takeObject( { position = cardVector, flip = false } ) --rotation = rotation,
		card.interactable = false
	end
end

function calculateCardPositions()
	local boardName, boardData, offsetTable

	-- go through each board center (boardPosition)
	for boardName, boardData in pairs(Ag.Boards.Main) do
		local activeBoard = getObjectFromGUID(boardData.guid)
		local activeBoardBounds = activeBoard.getBounds()
		local activeBoardCenter = activeBoardBounds['center']
		activeBoardCenter[2] = activeBoardCenter[2] + 0.5

		Ag.Boards.Main[boardName].rotation = activeBoard.getRotation() -- set the rotation dynamically
		local activeBoardScale = activeBoard.getScale()
		local scaleMultiplier = Game.call( 'vectorMath', {t1 = activeBoardScale, t2 = boardData.scale, operator = '/'} )

		--round off differences in scale to 1 (same) if between 0.98 and 1.02
		local multiplier
		local roundedScaleMultiplier = {}
		for _, multiplier in ipairs(scaleMultiplier) do
			if( (multiplier < 1.02) and (multiplier > 0.98) ) then
				table.insert(roundedScaleMultiplier, 1)
			else
				table.insert(roundedScaleMultiplier, multiplier)
			end
		end
		boardData.scaleMultiplier = roundedScaleMultiplier --replace previous division with rounded values if within tolerance

		-- calculate positions based on offsets
		local i
		for i, offsetTable in ipairs(boardData.positionOffsets) do
			local scaleFactoredOffsetTable = Game.call( 'vectorMath', { t1 = offsetTable, t2 = boardData.scaleMultiplier, operator = '*'} )
			--log('* * * SCALE FACTORED OFFSETS * * *')
			--log(scaleFactoredOffsetTable)
			local cardVector = {}

			--log('* * * Ag.Boards.Main[boardName].rotation * * * ')
			--log(Ag.Boards.Main[boardName].rotation)
			if( (Ag.Boards.Main[boardName].rotation[2] >= 180) and (Ag.Boards.Main[boardName].rotation[2] <= 359.99) ) then
				cardVector = Game.call( 'vectorMath', { t1 = activeBoardCenter, t2 = scaleFactoredOffsetTable, operator = '-' } )
			else
				cardVector = Game.call( 'vectorMath', { t1 = activeBoardCenter, t2 = scaleFactoredOffsetTable, operator = '+' } )
			end

			table.insert(boardData.cardPositions, cardVector)

			-- also create corresponding x,y,z indexes for 1,2,3 respectively
			local xyzIndex = Game.call('vectorNumberToLetter', i)
			if(xyzIndex ~= nil) then boardData.cardPositions[xyzIndex] = cardVector end
		end
	 end
end

function onClickDealOption()
  printToAll('Deal Options Changed!')
end

function onChangedHandSize()
  printToAll('Hand Size Set!')
end

function attachCardScripts()
	local seedCardScript = [===[
					function seed(tokenGUID)
							local cardRotation = self.getRotation()
							local bag = getObjectFromGUID(tokenGUID)
							local cardPosition = { position = self.getPosition() }

							if(cardRotation.z < 180.0) then
								bag.takeObject(cardPosition)
							end
					end
	]===]

	local card

	for _, cardSet in pairs(Ag.Cards) do
		for _, cardGUID in pairs(cardSet) do
			card = getObjectFromGUID(cardGUID)
			if(card ~= nil) then card.setLuaScript(seedCardScript) end
		end
	end
end

function calculatePlayerBoardPositions()
	local color, guid

	for color, guid in pairs(Ag.Boards.Players) do
		local board = getObjectFromGUID(guid)
		local position = board.getPosition()
		Ag.Players.homePositions[color] = position
	end
end

function roundToStage(round)
	if( (round >= 1) and (round <= 4) ) then return 1
	elseif( (round >= 5 ) and (round <=7 ) ) then return 2
	elseif( (round >= 8 ) and (round <= 9 ) ) then return 3
	elseif( (round >= 10 ) and (round <= 11 ) ) then return 4
	elseif( (round >= 12 ) and (round <= 13 ) ) then return 5
	elseif(round == 14 ) then return 6
	else return 0 end
end

-- bring peeps back to homes at the start of a new round
function recallPeeps()
	calculatePlayerBoardPositions()

	local color, peepGUID, peepObj

	for _, color in ipairs( Player.getAvailableColors() ) do
		--log('checking color '..color)
		--if(Ag.peeps[color] ~= nil) then
		for _, peepGUID in pairs(Ag.peeps[color]) do
			peepObj = getObjectFromGUID(peepGUID)
			if( peepObj ~= nil) then
				peepObj.setPositionSmooth(Ag.homePositions[color], false, true)
			end
				--peepPosition = peepObj.getPosition()
				--if(peepPosition[1] > -42) then
				--log(color..' peep '..peepGUID..' needs to come home!')
				--log(color..' peep '..peepGUID..' is at '..peepPosition[1]..', '..peepPosition[2]..', '..peepPosition[3])
				--end
		end
	end
end

function onClick_RotateHandsL()
  flipDraftCounters()
    local players = getRealSeatedPlayers()
    local playersClockwise = playersClockwise(players)
    --log('DEBUG: Number of seated players: ' .. #players)
    --log('DEBUG: Number of players clockwise: ' .. #playersClockwise)
    --for i,player in ipairs(playersClockwise) do
    --    log('DEBUG: ' .. i .. ' : ' .. player.color)
    --end
    for i, player in ipairs(playersClockwise) do
        local moveToIndex = 1
        if i == #players
        then
            moveToIndex = 1
        else
            moveToIndex = i + 1
        end
        local moveToPlayer = playersClockwise[moveToIndex]
        --log('DEBUG: Moving cards from ' .. i .. ' : ' .. player.color ..
        --    ' to ' .. moveToIndex .. ' : ' .. moveToPlayer.color)
        for i,card in ipairs(player.getHandObjects()) do
      			card.setPosition(getPlayerHandPosition(moveToPlayer))
      			card.setRotation({0, moveToPlayer.getHandTransform(1).rotation[2]+180, 0})
    		end
    end
end

function onClick_RotateHandsR()
  flipDraftCounters()
    local players = getRealSeatedPlayers()
    local playersCounterClockwise = playersCounterClockwise(players)
    --log('DEBUG: Number of seated players: ' .. #players)
    --log('DEBUG: Number of players clockwise: ' .. #playersClockwise)
    --for i,player in ipairs(playersClockwise) do
    --    log('DEBUG: ' .. i .. ' : ' .. player.color)
    --end
    for i, player in ipairs(playersCounterClockwise) do
        local moveToIndex = 1
        if i == #players
        then
            moveToIndex = 1
        else
            moveToIndex = i + 1
        end
        local moveToPlayer = playersCounterClockwise[moveToIndex]
        --log('DEBUG: Moving cards from ' .. i .. ' : ' .. player.color ..
        --    ' to ' .. moveToIndex .. ' : ' .. moveToPlayer.color)
        for i,card in ipairs(player.getHandObjects()) do
            card.setPosition(getPlayerHandPosition(moveToPlayer))
      			card.setRotation({0, moveToPlayer.getHandTransform(1).rotation[2]+180, 0})
        end
    end
end

function flipDraftCounters()
  y = getAllObjects()
  for i,v in pairs(y) do
    rotation = v.getRotation()
    zAxis = rotation[3]
    if v.getDescription() == 'Drafting Button' and zAxis <= 179.99 then
      v.flip()
    end
  end
end

function waitFrames(frames)
  while frames > 0 do
      coroutine.yield(0)
      frames = frames - 1
  end
end