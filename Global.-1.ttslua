function onload(saveState)
	Game = getObjectFromGUID('40398f') -- general helper object for common tasks

	Ag = {
		Bags = {
			decks = { E = '9eb064', I = '47d57c', K = '9e3d4c', WM = '28b771', FR = '8afe39',
								G = 'fb6a79', C = 'a4d426', FL = 'c54cb9', WA = '0b6410'},

			playerCards = { threePlayer = 'b4aad8', fourPlayer = 'eb2550', fivePlayer = '6fd961' },
			occupations = '8fc8a5', -- actual occs this game, after the selected decks have been assembled
			minors 			= '63ceb8'	-- actual minors this game, after the selected decks have been assembled

			--stages = { '70a876', '05db33', 'e8aa98', 'fa1c5e', 'eb4a6b', 'caae5b' } -- 1-6, respectively
		},
		Boards = {
			Players = { Red = '7c4084', Purple = 'd349b2', Green = '454b89', Blue = '858dea', White = '179cb5' },

			--TODO implement accounting for board resize when calculating seed positions
			Main = {
				DayLab = {
					cardPositions = {},
					guid = '78928b',
					positionOffsets = { {3.202, 0, -4.35}, {0.282, 0, -4.35}, {3.202, 0, 0},
															{0.282, 0, 0}, {3.202, 0, 4.531}, {0.282, 0, 4.531} },
					rotation = {},
					scale = {6.92, 1.00, 6.92},
					scaleMultiplier = {}
				},

				Fishing = {
					cardPositions = {},
					guid = 'e7d3f6',
					positionOffsets = {
						{-3.33, 0, -7.72}, {-0.17, 0,5.83}, {-0.17, 0,0.05},
						{-0.17,0,-4.54}, {3.06,0,4.24}, {3.06,0,-0.04}, {3.06, 0, -4.54}
					},
					rotation = {},
					scale = {6.92, 1.00, 6.92},
					scaleMultiplier = {}
				},

				EndGame = {
					cardPositions = {},
					guid = '375a44',
					positionOffsets = {
						{4.97,0,2.3}, {-4.32,0,-1.95}, {-1.75,0,2.26},
						{-1.75,0,-2.07}, {1.55,0,2.3}, {1.55,0,-2.21}, {4.48,0,2.3}
					},
					rotation = {},
					scale = {4.91, 1, 4.91},
					scaleMultiplier = {}
				},
			},
		},
		Buttons = { dealCards ='809d48' },
		Cards = {
			stages 			=	{ 'daa46a', '50efb8', 'e21d4c', '92f140', 'b54da2', 'a1e455' }, -- 1-5 are decks, [6] is round 14
			threePlayer = { clay = 'c2aaf9', wood2 = '11e22f', anyResource = '706011', occ = 'bc4db6' },
			fourPlayer	= { clay2 = '37a094', wood2 = 'aadc49', wood = '91aa89', gSpot = '2ee1f1', occ = '2a1d9a', tp = '2a1d9a' },
			fivePlayer 	= { clay3 = '1316e0', wood4 = '470341', zoo = 'b438d7', gSpot = '4db587', occ = 'd4d96d', tp = 'c8734c'},
			roundCards 	= { sheep = '85b867', majorMinor = 'cda9b3', fences = 'e5f7cd', sowBake = '8eeb11', fg = 'bded46',
										 stoneStage2 = '0d7a31', renoMajor = 'c8762e', boar = '6c1287', veg = '202efb', cattle = '1e18f2',
										 stoneStage4 = 'd37bf8', plowSow = '1a8ef8', fgWithoutSpace = '618af7', renoFence = 'a1e455'},
			beggingCardStack = 'f28a11'
		},
		Draft = { indicators = { Purple = "b57b80", Green = "80bcd4", Blue = "1c4ce5", White = "76cb43", Red = "abf3a9" } },
		Players = {
			homePositions = {},
			inGame = {},

			--TODO populate dynamically with GUIDs from spawn board
			peeps = { Purple = {'75d6bb', '8f914b', 'db306d', 'eb883c', 'f38a90'},
								Red = {'1145a1', 'bdefda', 'd291e4', '7aa697', '445dad'},
								Brown = {'063ea8', '0504ab', '60361a', 'e1cb00', '35b950'},
								Green = {'5ed89f', 'e082a2', 'fcd09c', 'b46095', 'e3f486'},
								Blue = {'98536c', '182092', 'c3ee56', '578516', '6bce00'} },
		},
		ScriptingZones = { deckSelectButtons = '8b293c' },
		SelectedDecks = {},
		SpawnBoard = {
			master = {
				food = getObjectFromGUID('8e8091'), grain = getObjectFromGUID('2459f4'), veg = getObjectFromGUID('391c13'),
				wood = getObjectFromGUID('c4d916'), clay = getObjectFromGUID('4e06e8'),  stone = getObjectFromGUID('fe3238'),
				reed = getObjectFromGUID('9c217a'), sheep = getObjectFromGUID('ca7c6c'), pig = getObjectFromGUID('d02a32'),
				cow = getObjectFromGUID('ee948a') }
		},
		Style = { broadcastTint = {200/255,1,200/255} }
	}

	createDealButton()
	calculatePlayerBoardPositions()


  --UI.setAttribute("dealButtons", "active", false)
  --UI.setAttribute("dealLayout", "height", 40)
	--startLuaCoroutine(Global, 'createDealButton')
	--calculateCardPositions()

	--TODO place this after cards are seeded
	--attachCardScripts() -- attach scripts to seed goodies, or whatevs in the future

  --setup_button = setup()
  --minors_button = minors_setup()
  --occs_button = occs_setup()
end

function update()
	--[[ The Update function. This is called once per frame. --]]
  --[[ log('Update loop!') --]]
end

function createDealButton()
	local dealButton = getObjectFromGUID(Ag.Buttons.dealCards)

	--local button = getObjectFromGUID(Ag.Buttons.startDraft)
  local params = {
		--click_function = 'onClickAssembleDecks("draft")',
		click_function = 'onClickDealCards',
	  position = {0, 0, 0},
	  width = 900,
	  height = 900
	}
  dealButton.createButton(params)
end

function onClickDealCards()
	getPlayers()
	local numPlayers = #Ag.Players.inGame

	if(numPlayers == 0) then
		broadcastToAll('Agricola plays 1-5 players!\n Click your name in the top right and select "Change Color".', Ag.Style.broadcastTint)
	elseif(numPlayers == 1) then
		broadcastToAll('Starting solo game', Ag.Style.broadcastTint)
		startGame(numPlayers)
	elseif(numPlayers < 6) then
		broadcastToAll('Starting game with ' .. numPlayers .. ' players', Ag.Style.broadcastTint)
		startGame(numPlayers)
	else
		broadcastToAll('Wow, big party, but maximum 5 players!', Ag.Style.broadcastTint)
	end
end

function getPlayers()
	local inGame = {}
	inGame = Game.call('playerSnapshot')

	local inGameCopy = copyTable(inGame)
	Ag.Players.inGame = inGameCopy
end

function copyTable(table)
	-- tables returned from external objects are protected from access, so need to copy them
	local k, v
	local copy = {}

	for k, v in pairs(table) do
			copy[k] = v
	end

	return copy
end

function startGame(numPlayers)
	calculateCardPositions()
	placePlayerDependentCards(4)
	--placeRoundCards()
	--assembleDecks(numPlayers)
	--dealCards()
end

function placePlayerDependentCards(numPlayers)
	print('setting up game for: ' .. numPlayers)
	local bagGUID
	if( numPlayers == 3 ) then
		bagGUID = Ag.Bags.playerCards.threePlayer
	elseif( numPlayers == 4 ) then
		bagGUID = Ag.Bags.playerCards.fourPlayer
	elseif( numPlayers == 5 ) then
		bagGUID = Ag.Bags.playerCards.fivePlayer
	end

	if( bagGUID ~= nil ) then
		local cardPile = getObjectFromGUID(bagGUID)
		cardPile.shuffle()
		--log('============ DayLab positions ============')
		--Game.call('dumpTable', Ag.Boards.Main.DayLab.cardPositions)
		local i, cardPosition
		for i, cardPosition in ipairs(Ag.Boards.Main.DayLab.cardPositions) do
			if( cardPosition ~= nil ) then
				--log('loop iteration i: ' .. i)
				cardPile.takeObject({ position = cardPosition, rotation = Ag.Boards.Main.DayLab.rotation, smooth = true })
				--Game.call('waitFrames', 15)
				--startLuaCoroutine(Global, 'placePlayerDependentCards(5)')
			end
		end
	end
	return 1
end

function placeRoundCards()
	local cardPositionCounter = 1
	local roundCounter, activeBoard, currentStage, cardPile

	for roundCounter = 1, 14 do
		if( roundCounter < 8 ) then
			activeBoard = Ag.Boards.Main.Fishing
		else
			activeBoard = Ag.Boards.Main.EndGame
			cardPositionCounter = 1
		end

		Game.call('dumpTable', activeBoard)
		currentStage = roundToStage(roundCounter)
		cardPile = getObjectFromGUID(Ag.Bags.stages[currentStage])
	--	log('* * * activeBoard.cardPosition[cardPositionCounter]:' .. activeBoard.cardPositions[cardPositionCounter])
		cardPile.takeObject( { position = activeBoard.cardPositions[cardPositionCounter], rotation = activeBoard.rotation } )
		cardPositionCounter = cardPositionCounter + 1
		Game.call('waitFrames', 15)
	end
end

function assembleDecks(numPlayers)
	local buttonZone = getObjectFromGUID(Ag.ScriptingZones.deckSelectButtons)
	local deckButtons = buttonZone.getObjects() -- Zone.getObjects() returns {Object, ...}
	local selectedDecks, sortedDecks, chosenDecks = {}, {}, {}
	local deckButton

	for _, deckButton in ipairs(deckButtons) do
		if( deckButton.getStateId() == 1) then
			table.insert( chosenDecks, deckButton.getName() )
		end
	end
	Ag.selectedDecks = chosenDecks

	if( Ag.selectedDecks == nil) then
		broadcastToAll("Please select at least one deck!", Ag.Style.broadcastTint)
	elseif( #(Ag.selectedDecks) >= 1 ) then
		local params = { unorderedTable = chosenDecks, orderedTable = Ag.Bags.decks }

		sortedDecks = Game.call('matchTableKeyOrder', params)

		local broadcastString = 'Decks in Play: '
		local deckName
		for _, deckName in ipairs(sortedDecks) do
			broadcastString = broadcastString .. deckName
		end
		broadcastToAll(broadcastString, Ag.Style.broadcastTint)
	end
end

function onClickDealOption()
  printToAll('Deal Options Changed!')
end

function onChangedHandSize()
  printToAll('Hand Size Set!')
end

function attachCardScripts()
	local seedCardScript = [===[
					function seed(tokenGUID)
							local cardRotation = self.getRotation()
							local bag = getObjectFromGUID(tokenGUID)
							local cardPosition = { position = self.getPosition() }

							if(cardRotation.z < 180.0) then
								bag.takeObject(cardPosition)
							end
					end
	]===]

	local card

	for _, cardSet in pairs(Ag.Cards) do
		for _, cardGUID in pairs(cardSet) do
			card = getObjectFromGUID(cardGUID)
			if(card ~= nil) then card.setLuaScript(seedCardScript) end
		end
	end
end

function calculatePlayerBoardPositions()
	local color, guid

	for color, guid in pairs(Ag.Boards.Players) do
		local board = getObjectFromGUID(guid)
		local position = board.getPosition()
		Ag.Players.homePositions[color] = position
	end
end

function calculateCardPositions()
	local boardName, boardData, offsetTable

	-- go through each board center (boardPosition)
	for boardName, boardData in pairs(Ag.Boards.Main) do
		local activeBoard = getObjectFromGUID(boardData.guid)
		local activeBoardBounds = activeBoard.getBounds()
		local activeBoardCenter = activeBoardBounds['center']
		activeBoardCenter[2] = activeBoardCenter[2] + 0.5

		Ag.Boards.Main[boardName].rotation = activeBoard.getRotation() -- set the rotation dynamically
		local activeBoardScale = activeBoard.getScale()
		local scaleMultiplier = Game.call( 'vectorMath', {t1 = activeBoardScale, t2 = boardData.scale, operator = '/'} )

		--round off differences in scale to 1 (same) if between 0.98 and 1.02
		local multiplier
		local roundedScaleMultiplier = {}
		for _, multiplier in ipairs(scaleMultiplier) do
			if( (multiplier < 1.02) and (multiplier > 0.98) ) then
				table.insert(roundedScaleMultiplier, 1)
			else
				table.insert(roundedScaleMultiplier, multiplier)
			end
		end
		boardData.scaleMultiplier = roundedScaleMultiplier --replace previous division with rounded values if within tolerance

		-- calculate positions based on offsets
		for _, offsetTable in ipairs(boardData.positionOffsets) do
			local scaleFactoredOffsetTable = Game.call( 'vectorMath', { t1 = offsetTable, t2 = boardData.scaleMultiplier, operator = '*'} )
			--log('* * * SCALE FACTORED OFFSETS * * *')
			--Game.call('dumpTable', scaleFactoredOffsetTable)
			local cardVector = {}

			--log('* * * Ag.Boards.Main[boardName].rotation * * * ')
			--Game.call('dumpTable', Ag.Boards.Main[boardName].rotation)
			if( (Ag.Boards.Main[boardName].rotation[2] >= 180) and (Ag.Boards.Main[boardName].rotation[2] <= 359.99) ) then
				cardVector = Game.call( 'vectorMath', { t1 = activeBoardCenter, t2 = scaleFactoredOffsetTable, operator = '-' } )
			else
				cardVector = Game.call( 'vectorMath', { t1 = activeBoardCenter, t2 = scaleFactoredOffsetTable, operator = '+' } )
			end

			table.insert(boardData.cardPositions, cardVector)
		end
	 end
end

function roundToStage(round)
	if( (round >= 1) and (round <= 4) ) then return 1
	elseif( (round >= 5 ) and (round <=7 ) ) then return 2
	elseif( (round >= 8 ) and (round <= 9 ) ) then return 3
	elseif( (round >= 10 ) and (round <= 11 ) ) then return 4
	elseif( (round >= 12 ) and (round <= 13 ) ) then return 5
	elseif(round == 14 ) then return 6
	else return 0 end
end

-- bring peeps back to homes at the start of a new round
function recallPeeps()
	local color, peepGUID, peepObj

	for _, color in ipairs( Player.getAvailableColors() ) do
		--log('checking color '..color)
		--if(Ag.peeps[color] ~= nil) then
		for _, peepGUID in pairs(Ag.peeps[color]) do
			peepObj = getObjectFromGUID(peepGUID)
			if( peepObj ~= nil) then
				peepObj.setPositionSmooth(Ag.homePositions[color], false, true)
			end
				--peepPosition = peepObj.getPosition()
				--if(peepPosition[1] > -42) then
				--log(color..' peep '..peepGUID..' needs to come home!')
				--log(color..' peep '..peepGUID..' is at '..peepPosition[1]..', '..peepPosition[2]..', '..peepPosition[3])
				--end
		end
	end
end

function onClick_RotateHandsL()
  flipDraftCounters()
    local players = getRealSeatedPlayers()
    local playersClockwise = playersClockwise(players)
    --log('DEBUG: Number of seated players: ' .. #players)
    --log('DEBUG: Number of players clockwise: ' .. #playersClockwise)
    --for i,player in ipairs(playersClockwise) do
    --    log('DEBUG: ' .. i .. ' : ' .. player.color)
    --end
    for i, player in ipairs(playersClockwise) do
        local moveToIndex = 1
        if i == #players
        then
            moveToIndex = 1
        else
            moveToIndex = i + 1
        end
        local moveToPlayer = playersClockwise[moveToIndex]
        --log('DEBUG: Moving cards from ' .. i .. ' : ' .. player.color ..
        --    ' to ' .. moveToIndex .. ' : ' .. moveToPlayer.color)
        for i,card in ipairs(player.getHandObjects()) do
      			card.setPosition(getPlayerHandPosition(moveToPlayer))
      			card.setRotation({0, moveToPlayer.getHandTransform(1).rotation[2]+180, 0})
    		end
    end
end

function onClick_RotateHandsR()
  flipDraftCounters()
    local players = getRealSeatedPlayers()
    local playersCounterClockwise = playersCounterClockwise(players)
    --log('DEBUG: Number of seated players: ' .. #players)
    --log('DEBUG: Number of players clockwise: ' .. #playersClockwise)
    --for i,player in ipairs(playersClockwise) do
    --    log('DEBUG: ' .. i .. ' : ' .. player.color)
    --end
    for i, player in ipairs(playersCounterClockwise) do
        local moveToIndex = 1
        if i == #players
        then
            moveToIndex = 1
        else
            moveToIndex = i + 1
        end
        local moveToPlayer = playersCounterClockwise[moveToIndex]
        --log('DEBUG: Moving cards from ' .. i .. ' : ' .. player.color ..
        --    ' to ' .. moveToIndex .. ' : ' .. moveToPlayer.color)
        for i,card in ipairs(player.getHandObjects()) do
            card.setPosition(getPlayerHandPosition(moveToPlayer))
      			card.setRotation({0, moveToPlayer.getHandTransform(1).rotation[2]+180, 0})
        end
    end
end

function flipDraftCounters()
  y = getAllObjects()
  for i,v in pairs(y) do
    rotation = v.getRotation()
    zAxis = rotation[3]
    if v.getDescription() == 'Drafting Button' and zAxis <= 179.99 then
      v.flip()
    end
  end
end

function waitFrames(frames)
  while frames > 0 do
      coroutine.yield(0)
      frames = frames - 1
  end
end